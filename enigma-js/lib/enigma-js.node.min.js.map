{"version":3,"sources":["webpack://enigma-js/webpack/universalModuleDefinition","webpack://enigma-js/webpack/bootstrap","webpack://enigma-js/external \"node-forge\"","webpack://enigma-js/external \"eventemitter3\"","webpack://enigma-js/external \"jsbi\"","webpack://enigma-js/external \"web3-utils\"","webpack://enigma-js/external \"buffer\"","webpack://enigma-js/external \"zlib\"","webpack://enigma-js/external \"eth-crypto\"","webpack://enigma-js/external \"elliptic\"","webpack://enigma-js/external \"jayson/lib/client/browser\"","webpack://enigma-js/external \"axios\"","webpack://enigma-js/external \"retry\"","webpack://enigma-js/external \"ethereumjs-abi\"","webpack://enigma-js/external \"core-js/stable\"","webpack://enigma-js/external \"regenerator-runtime/runtime\"","webpack://enigma-js/./src/enigma-utils.js","webpack://enigma-js/./src/emitterConstants.js","webpack://enigma-js/./src/Admin.js","webpack://enigma-js/./src/models/Task.js","webpack://enigma-js/./src/Enigma.js","webpack://enigma-js/./src/index.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","forge","options","usePureJavaScript","EC","elliptic","ec","appendMessages","hexStr","inputsArray","principalPrefix","input","remove0x","JSBI","BigInt","length","toString","padStart","appendArrayMessages","array","hexString","substring","utils","sender","nonce","web3Utils","soliditySha3","v","seed","workerAddresses","workerStakes","codeHash","inputsHashes","lastStateDeltaHash","stateDeltaHashes","outputHashes","gasesUsed","optionalEthereumData","optionalEthereumContractAddress","successFlag","enclavePublicKey","clientPrivateKey","clientKey","keyFromPrivate","sharedPoints","keyFromPublic","getPublic","mul","getPrivate","y","getY","isOdd","x","getX","yBuffer","Buffer","from","xBuffer","toArrayLike","sha256","md","update","digest","toHex","keyHex","msg","iv","random","getBytesSync","util","hexToBytes","cipher","createCipher","start","createBuffer","finish","output","putBuffer","tag","putBytes","msgHex","msgBuf","slice","decipher","createDecipher","Error","engValue","hexToAscii","replace","stack","code","parseInt","substr","isNaN","push","String","fromCharCode","join","sleep","ms","Promise","resolve","setTimeout","gzip","buffer","reject","zlib","error","result","gunzip","ERROR","DEPOSIT_TRANSACTION_HASH","DEPOSIT_CONFIRMATION","DEPOSIT_RECEIPT","WITHDRAW_TRANSACTION_HASH","WITHDRAW_CONFIRMATION","WITHDRAW_RECEIPT","LOGIN_TRANSACTION_HASH","LOGIN_CONFIRMATION","LOGIN_RECEIPT","LOGOUT_TRANSACTION_HASH","LOGOUT_CONFIRMATION","LOGOUT_RECEIPT","UNREGISTER_TRANSACTION_HASH","UNREGISTER_CONFIRMATION","UNREGISTER_RECEIPT","SET_OPERATING_ADDRESS_TRANSACTION_HASH","SET_OPERATING_ADDRESS_CONFIRMATION","SET_OPERATING_ADDRESS_RECEIPT","DEPLOY_SC_ADDR_RESULT","DEPLOY_SC_ETH_TRANSACTION_HASH","DEPLOY_SC_ETH_CONFIRMATION","DEPLOY_SC_ETH_RECEIPT","DEPLOY_SC_ENG_RECEIPT","CREATE_TASK","CREATE_TASK_INPUT","CREATE_TASK_RECORD_TRANSACTION_HASH","CREATE_TASK_RECORD_CONFIRMATION","CREATE_TASK_RECORD_RECEIPT","CREATE_TASK_RECORD","SEND_TASK_INPUT_RESULT","POLL_TASK_STATUS_RESULT","GET_TASK_RESULT_RESULT","DEPLOY_SECRET_CONTRACT_RESULT","RETURN_FEES_FOR_TASK_RECEIPT","RETURN_FEES_FOR_TASK","POLL_TASK_ETH_RESULT","RPC_SEND_TASK_INPUT","RPC_DEPLOY_SECRET_CONTRACT","RPC_GET_TASK_RESULT","RPC_GET_TASK_STATUS","GET_TASK_RESULT_SUCCESS","GET_TASK_RESULT_FAILED","GET_TASK_RESULT_UNVERIFIED","GET_TASK_RESULT_INPROGRESS","ETH_STATUS_UNDEFINED","ETH_STATUS_CREATED","ETH_STATUS_VERIFIED","ETH_STATUS_FAILED","ETH_STATUS_FAILED_ETH","ETH_STATUS_FAILED_RETURN","Admin","web3","enigmaContract","tokenContract","txDefaults","enigma","this","sigAddr","methods","getWorkerFromSigningAddress","account","stakingAddress","status","report","balance","logs","getWorker","worker","scAddr","getSecretContract","countSecretContracts","stop","getSecretContractAddresses","getAllSecretContractAddresses","index","stateDeltaHash","includes","emitter","EventEmitter","async","login","send","on","hash","emit","eeConstants","confirmationNumber","receipt","message","operatingAddress","setOperatingAddress","logout","unregister","amount","balanceOf","approve","address","deposit","withdraw","signer","getOperatingAddressFromStakingAddress","Task","encryptedFn","encryptedAbiEncodedArgs","gasLimit","gasPx","msgId","userPubKey","firstBlockNumber","workerAddress","workerEncryptionKey","userTaskSig","preCode","preCodeHash","isContractDeploymentTask","inputsHash","transactionHash","taskId","ethStatus","proof","creationBlockNumber","encryptedAbiEncodedOutputs","delta","usedGas","ethereumPayload","ethereumAddress","workerTaskSig","engStatus","decryptedOutput","Enigma","enigmaContractAddr","tokenContractAddr","rpcAddr","config","retry","retries","factor","minTimeout","maxTimeout","randomize","client","jaysonBrowserClient","request","callback","axios","post","JSON","parse","headers","then","response","data","text","stringify","err","workerParamsCache","selectedWorkerGroupCache","taskKeyLocalStorage","createContracts","task","encryptedArgs","userDHKey","contractAddress","admin","eth","Contract","EnigmaContract","EnigmaTokenContract","fn","args","scAddrOrPreCode","getUserTaskDeployments","generateScAddr","isBuffer","preCodeGzip","argsTranspose","undefined","map","col","row","abiEncodedArgs","abi","encodeParameters","abiEncodedArgsArray","getBlockNumber","blockNumber","getWorkerParams","workerParams","selectWorkerGroup","toLowerCase","obtainTaskKeyPair","publicKey","privateKey","getWorkerEncryptionKeyResult","id","workerSig","hexToVerify","recAddress","EthCrypto","recover","console","derivedKey","getDerivedKey","encryptMessage","sign","increaseAllowance","createDeploymentTaskRecord","createTaskRecord","events","TaskRecordCreated","returnValues","getTaskRecord","taskRecord","outputHash","custodian","getReport","keys","epochSize","getEpochSize","getWorkerParamsResult","workers","stakes","params","workerGroupSize","tokenCpt","reduce","a","b","add","selectedWorkers","keccak256","randVal","remainder","selectedWorker","subtract","rpcEndpointName","emitName","serializeTask","operation","attempt","currentAttempt","getTaskResultResult","signature","log","getTaskTimeoutSize","taskTimeoutSize","returnFeesForTask","decryptMessage","getTaskOutputHash","ethOutputHash","engOutputHash","getTaskRecordStatus","withResult","generator","next","innerPollTaskStatus","pollTaskStatusGen","interval","getTaskId","isBrowser","window","atob","localStorage","getItem","seedTask","createInstance","seedFileSync","needed","fillString","bytesToHex","getBytes","publicKeyByPrivateKey","setItem","btoa","characters","charAt","Math","floor","maxRetries","retryCount","createTask","scTask","sendTaskInput"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,YAAa,GAAIH,GACE,iBAAZC,QACdA,QAAQ,aAAeD,IAEvBD,EAAK,aAAeC,IARtB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,I,gBClFrDtC,EAAOD,QAAUwC,QAAQ,e,cCAzBvC,EAAOD,QAAUwC,QAAQ,kB,cCAzBvC,EAAOD,QAAUwC,QAAQ,S,cCAzBvC,EAAOD,QAAUwC,QAAQ,e,cCAzBvC,EAAOD,QAAUwC,QAAQ,W,cCAzBvC,EAAOD,QAAUwC,QAAQ,S,cCAzBvC,EAAOD,QAAUwC,QAAQ,e,cCAzBvC,EAAOD,QAAUwC,QAAQ,a,00/0BCAzBvC,EAAOD,QAAUwC,QAAQ,8B,cCAzBvC,EAAOD,QAAUwC,QAAQ,U,cCAzBvC,EAAOD,QAAUwC,QAAQ,U,cCAzBvC,EAAOD,QAAUwC,QAAQ,mB,+CCAzBvC,EAAOD,QAAUwC,QAAQ,mB,cCAzBvC,EAAOD,QAAUwC,QAAQ,gC,w6FCQzBC,IAAMC,QAAQC,mBAAoB,EAElC,IAAMC,EAAKC,IAASC,GAqLpB,SAASC,EAAeC,EAAQC,GAA8B,IACtDC,EADsD,wDACxB,KAAO,GADiB,uBAE5D,YAAkBD,EAAlB,+CAA+B,KAAtBE,EAAsB,QAC7BA,EAAQC,EAASD,GAEjBH,GAAUE,EAAkBG,IAAKC,OAAOH,EAAMI,OAAO,GAAGC,SAAS,IAAIC,SAAS,GAAI,KAAON,GAL/B,kFAO5D,OAAOH,EAWT,SAASU,EAAoBV,EAAQC,GACnC,IADgD,uBAEhD,YAAoBA,EAApB,+CAAiC,KAAtBU,EAAsB,QAE/BX,EAASD,EADTC,GAFsB,KAEMK,IAAKC,OAAOK,EAAM,GAAGJ,QAAUI,EAAM,GAAG,IAAIH,SAAS,IAAIC,SAAS,GAAI,KAClEE,EAAM,IAAI,IAJI,kFAMhD,OAAOX,EAsPT,SAASI,EAASQ,GAChB,MAAiC,MAA7BA,EAAUC,UAAU,EAAG,GAClBD,EAAUC,UAAU,GAEpBD,EAoEX,IAAME,EAAQ,CAIdA,KAAa,iBAAM,UAEnBA,eA5WA,SAAwBC,EAAQC,GAC9B,OAAOC,IAAUC,aACb,CAACxC,EAAG,QAASyC,EAAGJ,GAChB,CAACrC,EAAG,OAAQyC,EAAGH,KA0WrBF,KA5TA,SAAcb,GACZ,IAAMD,EAASD,EAAe,GAAIE,GAClC,OAAOgB,IAAUC,aAAa,CAACxC,EAAG,QAASyC,EAAGnB,KA2ThDc,cA/SA,SAAuBM,EAAMJ,EAAOK,EAAiBC,GACnD,IAAItB,EAAS,GAGb,OADAA,EAASU,EADTV,EAASD,EAAeC,EAAQ,CAACoB,EAAMJ,IAAQ,GACV,CAAC,CAACK,EAAiB,IAAK,CAACC,EAAc,MACrEL,IAAUC,aAAa,CAACxC,EAAG,QAASyC,EAAGnB,KA4ShDc,mBA3RA,SAA4BS,EAAUC,EAAcC,EAAoBC,EAAkBC,EAAcC,EACpGC,EAAsBC,EAAiCC,GACzD,IAAI/B,EAAS,GAOb,OANAA,EAASD,EAAeC,EAAQ,CAACuB,IAEjCvB,EAASD,EADTC,EAASU,EAAoBV,EAAQ,CAACwB,IACN,CAACC,IAEjCzB,EAASD,EADTC,EAASU,EAAoBV,EAAQ,CAAC0B,EAAkBC,EAAcC,IACtC,CAACC,EAAsBC,EAAiCC,IAEjFd,IAAUC,aAAa,CAACxC,EAAG,QAASyC,EAAGnB,KAyRhDc,cA1LA,SAAuBkB,EAAkBC,GACvC,IAAMnC,EAAK,IAAIF,EAAG,aAEa,KAA3BoC,EAAiBzB,SACnByB,EAAmB,KAAOA,GAG5B,IAAME,EAAYpC,EAAGqC,eAAeF,EAAkB,OAGhDG,EAFatC,EAAGuC,cAAcL,EAAkB,OAEtBM,YAAYC,IAAIL,EAAUM,cACpDC,EAAI,GAAQL,EAAaM,OAAOC,QAAU,EAAI,GAC9CC,EAAIR,EAAaS,OACjBC,EAAUC,SAAOC,KAAK,CAACP,IACvBQ,EAAUL,EAAEM,YAAYH,SAAQ,KAAM,IAEtCI,EAAS1D,IAAM2D,GAAGD,OAAOrE,SAK/B,OAHAqE,EAAOE,OAAOP,EAAQtC,SAAS,WAC/B2C,EAAOE,OAAOJ,EAAQzC,SAAS,WAExB2C,EAAOG,SAASC,SAsKzBzC,eAhIA,SAAwB0C,EAAQC,GAAyC,IAApCC,EAAoC,uDAA/BjE,IAAMkE,OAAOC,aAAa,IAC5D7E,EAAMU,IAAMoE,KAAKC,WAAWN,GAC5BO,EAAStE,IAAMsE,OAAOC,aAAa,UAAWjF,GAQpD,OANAgF,EAAOE,MAAM,CAACP,GAAIA,IAClBK,EAAOV,OAAO5D,IAAMoE,KAAKK,aAAaT,IACtCM,EAAOI,SAEQJ,EAAOK,OAAOC,UAAUN,EAAOpF,KAAK2F,KAAKC,SAASb,GAEnDH,SAuHhBzC,eA5JA,SAAwB0C,EAAQgB,GAC9B,IAAMzF,EAAMU,IAAMoE,KAAKC,WAAWN,GAC5BiB,EAAS1B,SAAOC,KAAKwB,EAAQ,OAC7Bd,EAAKjE,IAAMoE,KAAKK,aAAaO,EAAOC,OAAO,KAC3CJ,EAAM7E,IAAMoE,KAAKK,aAAaO,EAAOC,OAAO,IAAK,KACjDC,EAAWlF,IAAMsE,OAAOa,eAAe,UAAW7F,GAMxD,GAJA4F,EAASV,MAAM,CAACP,GAAIA,EAAIY,IAAKA,IAC7BK,EAAStB,OACL5D,IAAMoE,KAAKK,aAAaO,EAAOC,MAAM,GAAI,MAEzCC,EAASR,SACX,OAAOQ,EAASP,OAAOb,QAEzB,MAAM,IAAIsB,MAAM,4BA+IlB/D,SA/GA,SAAkBgE,GAChB,OAAOA,EAAW,KAAH,IAAG,GAAI,KAgHxBhE,EAAMV,SAAWA,EACjBU,EAAMiE,WAhFN,SAAoBnE,GAClB,GAA2B,iBAAdA,GAA8C,iBAAbA,EAC5C,MAAO,GAETA,EAAYA,EAAUJ,WAAWwE,QAAQ,QAAS,IAElD,IADA,IAAMC,EAAQ,GACLhG,EAAI,EAAGA,EAAI2B,EAAUL,OAAQtB,GAAK,EAAG,CAC5C,IAAMiG,EAAOC,SAASvE,EAAUwE,OAAOnG,EAAG,GAAI,IACzCoG,MAAMH,IAAkB,IAATA,GAClBD,EAAMK,KAAKC,OAAOC,aAAaN,IAGnC,OAAOD,EAAMQ,KAAK,KAqEpB3E,EAAM4E,MA5DN,SAAeC,GACb,OAAO,IAAIC,SAAQ,SAACC,GAAD,OAAaC,WAAWD,EAASF,OA4DtD7E,EAAMiF,KArDN,SAAcC,GACZ,OAAO,IAAIJ,SAAQ,SAACC,EAASI,GAC3BC,IAAKH,KAAKC,GAAQ,SAACG,EAAOC,GACpBD,EACFF,EAAOE,GAEPN,EAAQO,UAgDhBtF,EAAMuF,OAtCN,SAAgBL,GACd,OAAO,IAAIJ,SAAQ,SAACC,EAASI,GAC3BC,IAAKG,OAAOL,GAAQ,SAACG,EAAOC,GACtBD,EACFF,EAAOE,GAEPN,EAAQO,UAkCDtF,Q,8BChjBFwF,EAAQ,QACRC,EAA2B,yBAC3BC,EAAuB,sBACvBC,EAAkB,iBAClBC,EAA4B,0BAC5BC,EAAwB,uBACxBC,EAAmB,kBACnBC,EAAyB,uBACzBC,EAAqB,oBACrBC,EAAgB,eAChBC,EAA0B,wBAC1BC,EAAsB,qBACtBC,EAAiB,gBACjBC,EAA8B,4BAC9BC,EAA0B,yBAC1BC,EAAqB,oBACrBC,EAAyC,qCACzCC,EAAqC,kCACrCC,EAAgC,6BAEhCC,EAAwB,qBACxBC,EAAiC,6BACjCC,EAA6B,0BAC7BC,EAAwB,qBACxBC,EAAwB,qBAExBC,EAAc,aACdC,EAAoB,kBACpBC,EAAsC,kCACtCC,EAAkC,+BAClCC,EAA6B,0BAC7BC,GAAqB,mBAErBC,GAAyB,sBACzBC,GAA0B,uBAC1BC,GAAyB,sBACzBC,GAAgC,6BAEhCC,GAA+B,2BAC/BC,GAAuB,oBAEvBC,GAAuB,oBAEvBC,GAAsB,gBACtBC,GAA6B,uBAC7BC,GAAsB,gBACtBC,GAAsB,gBACtBC,GAA0B,UAC1BC,GAAyB,SACzBC,GAA6B,aAC7BC,GAA6B,aAE7BC,GAAuB,EACvBC,GAAqB,EACrBC,GAAsB,EACtBC,GAAoB,EACpBC,GAAwB,EACxBC,GAA2B,E,2KCnDnBC,G,WASnB,WAAYC,EAAMC,EAAgBC,EAAeC,EAAYC,I,4FAAQ,SACnEC,KAAKL,KAAOA,EACZK,KAAKJ,eAAiBA,EACtBI,KAAKH,cAAgBA,EACrBG,KAAKF,WAAaA,EAClBE,KAAKD,OAASA,E,oEASWE,G,gIACJD,KAAKJ,eAAeM,QAAQC,4BAA4BF,GAASrM,Q,cAAhFyI,E,yBACC,CACL+D,QAAS/D,EAAO,GAChBgE,eAAgBhE,EAAO,GAAG,GAC1BiE,OAAQlF,SAASiB,EAAO,GAAG,IAC3BkE,OAAQlE,EAAO,GAAG,GAClBmE,QAASpF,SAASiB,EAAO,GAAG,IAC5BoE,KAAMpE,EAAO,GAAG,K,uFAUE+D,G,gIACCJ,KAAKJ,eAAeM,QAAQQ,UAAUN,GAASxM,Q,cAA9D+M,E,yBACCvF,SAASuF,EAAOL,S,kFASRM,G,6FACRxF,S,kCAAgB4E,KAAKJ,eAAeM,QAAQW,kBAAkBD,GAAQhN,Q,0BAAQ0M,O,sCAAY,I,iMAS1FlF,S,kCAAe4E,KAAKJ,eAAeM,QAAQY,uBAAuBlN,Q,8JAU1CsG,EAAO6G,G,0HACxBf,KAAKJ,eAAeM,QAAQc,2BAA2B9G,EAAO6G,GAAMnN,Q,yQASpEoM,KAAKJ,eAAeM,QAAQe,gCAAgCrN,Q,2HAS1DgN,G,0HACFZ,KAAKJ,eAAeM,QAAQW,kBAAkBD,GAAQhN,Q,uCAAQ4D,U,wFASvDoJ,G,0HACPZ,KAAKJ,eAAeM,QAAQW,kBAAkBD,GAAQhN,Q,uCAAQ+D,iBAAiBnB,Q,yFAUvEoK,EAAQM,G,0HAChBlB,KAAKJ,eAAeM,QAAQW,kBAAkBD,GAAQhN,Q,mBAAyBsN,E,yBAAjBvJ,iB,kGAWpDiJ,EAAQ1G,EAAO6G,G,0HACzBf,KAAKJ,eAAeM,QAAQW,kBAAkBD,GAAQhN,Q,mBAA+BsG,E,KAAO6G,E,yBAA9BpJ,iBAAiBgD,M,oGAUxEiG,EAAQO,G,0HACfnB,KAAKJ,eAAeM,QAAQW,kBAAkBD,GAAQhN,Q,mBAChEuN,E,yBADwExJ,iBAAiByJ,S,oFAUzFhB,GAAS,WACPiB,EAAU,IAAIC,IAcpB,OAbC,mBAAAC,OAAA,kGAES,EAAK3B,eAAeM,QAAQsB,QAAQC,KAAK,CAACxI,KAAMmH,IAAUsB,GAAG,mBAAmB,SAACC,GACrFN,EAAQO,KAAKC,EAAoCF,MAChDD,GAAG,gBAAgB,SAACI,EAAoBC,GACzCV,EAAQO,KAAKC,EAAgCC,EAAoBC,MAChEL,GAAG,WAAW,SAACK,GAChBV,EAAQO,KAAKC,EAA2BE,OAP7C,sDAUGV,EAAQO,KAAKC,EAAmB,KAAIG,SAVvC,uDAaMX,I,0CAUWhB,EAAgB4B,GAAkB,WAC9CZ,EAAU,IAAIC,IAgBpB,OAfC,mBAAAC,OAAA,kGAES,EAAK3B,eAAeM,QAAQgC,oBAAoBD,GAAkBR,KAAK,CAC3ExI,KAAMoH,IACLqB,GAAG,mBAAmB,SAACC,GACxBN,EAAQO,KAAKC,EAAoDF,MAChED,GAAG,gBAAgB,SAACI,EAAoBC,GACzCV,EAAQO,KAAKC,EAAgDC,EAAoBC,MAChFL,GAAG,WAAW,SAACK,GAChBV,EAAQO,KAAKC,EAA2CE,OAT7D,sDAYGV,EAAQO,KAAKC,EAAmB,KAAIG,SAZvC,uDAeMX,I,6BASFjB,GAAS,WACRiB,EAAU,IAAIC,IAcpB,OAbC,mBAAAC,OAAA,kGAES,EAAK3B,eAAeM,QAAQiC,SAASV,KAAK,CAACxI,KAAMmH,IAAUsB,GAAG,mBAAmB,SAACC,GACtFN,EAAQO,KAAKC,EAAqCF,MACjDD,GAAG,gBAAgB,SAACI,EAAoBC,GACzCV,EAAQO,KAAKC,EAAiCC,EAAoBC,MACjEL,GAAG,WAAW,SAACK,GAChBV,EAAQO,KAAKC,EAA4BE,OAP9C,sDAUGV,EAAQO,KAAKC,EAAmB,KAAIG,SAVvC,uDAaMX,I,iCASEjB,GAAS,WACZiB,EAAU,IAAIC,IAcpB,OAbC,mBAAAC,OAAA,kGAES,EAAK3B,eAAeM,QAAQkC,aAAaX,KAAK,CAACxI,KAAMmH,IAAUsB,GAAG,mBAAmB,SAACC,GAC1FN,EAAQO,KAAKC,EAAyCF,MACrDD,GAAG,gBAAgB,SAACI,EAAoBC,GACzCV,EAAQO,KAAKC,EAAqCC,EAAoBC,MACrEL,GAAG,WAAW,SAACK,GAChBV,EAAQO,KAAKC,EAAgCE,OAPlD,sDAUGV,EAAQO,KAAKC,EAAmB,KAAIG,SAVvC,uDAaMX,I,8BAUDjB,EAASiC,GAAQ,IAEtB,EAFsB,OACjBhB,EAAU,IAAIC,IA0BpB,OAzBC,mBAAAC,OAAA,yFACuB,EAAK1B,cAAcK,QAAQoC,UAAUlC,GAASxM,QADrE,mBAEeyO,GAFf,uBAIGhB,EAAQO,KAAK,QAAS,CACpB5N,KAAM,kBACNgO,QAHU,gCAHf,mEAUO,EAAKnC,cAAcK,QAAQqC,QAAQ,EAAK3C,eAAejK,QAAQ6M,QAASH,GAAQZ,KAAK,CAACxI,KAAMmH,KAVnG,0DAYyB,EAAKR,eAAeM,QAAQuC,QAAQrC,EAASiC,GAC9DZ,KAAK,CAACxI,KAAMmH,IACZsB,GAAG,mBAAmB,SAACC,GACtBN,EAAQO,KAAKC,EAAsCF,MAEpDD,GAAG,gBAAgB,SAACI,EAAoBC,GACvCV,EAAQO,KAAKC,EAAkCC,EAAoBC,OAlB5E,QAYSA,EAZT,OAoBGV,EAAQO,KAAKC,EAA6BE,GApB7C,kDAsBGV,EAAQO,KAAKC,EAAmB,KAAIG,SAtBvC,yDAyBMX,I,+BAWAjB,EAASiC,GAAQ,WAClBhB,EAAU,IAAIC,IAkBpB,OAjBC,mBAAAC,OAAA,kGAES,EAAK3B,eAAeM,QAAQwC,SAASL,GACvCZ,KAAK,CAACxI,KAAMmH,IACZsB,GAAG,mBAAmB,SAACC,GACrBN,EAAQO,KAAKC,EAAuCF,MAEtDD,GAAG,gBAAgB,SAACI,EAAoBC,GACtCV,EAAQO,KAAKC,EAAmCC,EAAoBC,MAEtEL,GAAG,WAAW,SAACK,GACbV,EAAQO,KAAKC,EAA8BE,OAXpD,sDAcGV,EAAQO,KAAKC,EAAmB,KAAIG,SAdvC,uDAiBMX,I,iCASQjB,G,6FACRhF,S,kCAAgB4E,KAAKJ,eAAeM,QAAQQ,UAAUN,GAASxM,Q,0BAAQ4M,Q,6HAStDJ,G,0HACVJ,KAAKJ,eAAeM,QAAQQ,UAAUN,GAASxM,Q,uCAAQ+O,Q,6GAS3BvC,G,0HAC7BJ,KAAKJ,eAAeM,QAAQ0C,sCAAsCxC,GAASxM,Q,kIC9UvEiP,GAsBnB,WAAYjC,EAAQkC,EAAaC,EAAyBC,EAAUC,EAAOC,EAAOC,EAAYC,EAC1FC,EAAeC,EAAqBtM,EAAQuM,EAAatM,EAAOuM,EAASC,EACzEC,I,4FAA0B,SAE5B1D,KAAK2D,WAAa5M,EAAM4K,KAAK,CAACmB,EAAaC,EACzCW,EAA2BD,EAAc7C,EAAQuC,IACnDnD,KAAKY,OAASA,EACdZ,KAAK8C,YAAcA,EACnB9C,KAAK+C,wBAA0BA,EAC/B/C,KAAKgD,SAAWA,EAChBhD,KAAKiD,MAAQA,EACbjD,KAAKkD,MAAQA,EACblD,KAAKmD,WAAaA,EAClBnD,KAAKoD,iBAAmBA,EACxBpD,KAAKqD,cAAgBA,EACrBrD,KAAKsD,oBAAsBA,EAC3BtD,KAAKhJ,OAASA,EACdgJ,KAAKuD,YAAcA,EACnBvD,KAAK/I,MAAQA,EACb+I,KAAKwD,QAAUA,EACfxD,KAAKyD,YAAcA,EACnBzD,KAAK0D,yBAA2BA,EAKhC1D,KAAK4D,gBAAkB,GACvB5D,KAAK6D,OAAS,GACd7D,KAAK+B,QAAU,GACf/B,KAAK8D,UAAY,EACjB9D,KAAK+D,MAAQ,GACb/D,KAAKgE,qBAAuB,EAG5BhE,KAAKiE,2BAA6B,GAClCjE,KAAKkE,MAAQ,GACblE,KAAKmE,QAAU,GACfnE,KAAKoE,gBAAkB,GACvBpE,KAAKqE,gBAAkB,GACvBrE,KAAKsE,cAAgB,GACrBtE,KAAKuE,UAAY,OAEjBvE,KAAKwE,gBAAkB,I,0eCjDNC,G,WAWnB,WAAY9E,EAAM+E,EAAoBC,EAAmBC,GAAuC,IAA9B9E,EAA8B,uDAAjB,GAAI+E,EAAa,uDAAJ,I,4FAAI,SAC9F7E,KAAKL,KAAOA,EACZK,KAAKF,WAAaA,EAElBE,KAAK6E,OAAS,GACd7E,KAAK6E,OAAOC,MAAQ,GACpB9E,KAAK6E,OAAOC,MAAMC,QAAUF,EAAOC,OACR,MAAxBD,EAAOC,MAAMC,QAAkBF,EAAOC,MAAMC,QAAe,EAC9D/E,KAAK6E,OAAOC,MAAME,OAASH,EAAOC,OACR,MAAvBD,EAAOC,MAAME,OAAiBH,EAAOC,MAAME,OAAc,EAC5DhF,KAAK6E,OAAOC,MAAMG,WAAaJ,EAAOC,OACR,MAA3BD,EAAOC,MAAMG,WAAqBJ,EAAOC,MAAMG,WAAqB,IACvEjF,KAAK6E,OAAOC,MAAMI,WAAaL,EAAOC,OACR,MAA3BD,EAAOC,MAAMI,WAAqBL,EAAOC,MAAMI,WAA2B,WAC7ElF,KAAK6E,OAAOC,MAAMK,WAAYN,EAAOC,QACR,MAA1BD,EAAOC,MAAMK,WAAoBN,EAAOC,MAAMK,WAqBjDnF,KAAKoF,OAASC,MAlBK,SAASC,EAASC,GAOnCC,KAAMC,KAAKb,EAASc,KAAKC,MAAML,GANhB,CACbM,QAAS,CACP,eAAgB,mBAChB,YAAe,aAG8BC,MAAK,SAACC,GACrD,GAAIjE,KAAqBiE,EAASC,KAChCR,EAASO,EAASC,KAAK3J,MAAO,UACzB,CACL,IAAM4J,EAAON,KAAKO,UAAUH,EAASC,KAAK1J,QAC1CkJ,EAAS,KAAMS,OALnB,OAOS,SAASE,GAChBX,EAAS,CAACpK,MAAO,KAAO6G,QAASkE,EAAIlE,SAAU,WAGL,IAC9ChC,KAAKmG,kBAAoB,GACzBnG,KAAKoG,yBAA2B,GAChCpG,KAAKqG,oBAAsB,GAC3BrG,KAAKsG,gBAAgB5B,EAAoBC,G,4DA6jBtB4B,GACnB,OAAOA,EAAK7C,yBAA2B,CACrCF,QAAS+C,EAAK/C,QACdgD,cAAezP,EAAMV,SAASkQ,EAAKxD,yBAA0BD,YAAa/L,EAAMV,SAASkQ,EAAKzD,aAC9F2D,UAAW1P,EAAMV,SAASkQ,EAAKpD,YAAauD,gBAAiB3P,EAAMV,SAASkQ,EAAK3F,QACjFyC,cAAekD,EAAKlD,eAClB,CACFQ,OAAQ9M,EAAMV,SAASkQ,EAAK1C,QAASR,cAAekD,EAAKlD,cACzDP,YAAa/L,EAAMV,SAASkQ,EAAKzD,aAAc0D,cAAezP,EAAMV,SAASkQ,EAAKxD,yBAClF2D,gBAAiB3P,EAAMV,SAASkQ,EAAK3F,QAAS6F,UAAW1P,EAAMV,SAASkQ,EAAKpD,e,gCA0L/E,MAAO,Y,iCAzvBPnD,KAAK2G,MAAQ,IAAIjH,GAAMM,KAAKL,KAAMK,KAAKJ,eAAgBI,KAAKH,cAAeG,KAAKF,WAAYE,Q,sCAS9E0E,EAAoBC,GAClC3E,KAAKJ,eAAiB,IAAII,KAAKL,KAAKiH,IAAIC,SAASC,EAAc,IAC3DpC,EAAoB1E,KAAKF,YAC7BE,KAAKH,cAAgB,IAAIG,KAAKL,KAAKiH,IAAIC,SAASE,EAAmB,IAC/DpC,EAAmB3E,KAAKF,c,iCAiBnBkH,EAAIC,EAAMjE,EAAUC,EAAOjM,EAAQkQ,EAAiBxD,GAA0B,IAEtF,wDAFsF,OACjFrC,EAAU,IAAIC,IA0FpB,OAzFC,mBAAAC,OAAA,4DAEenG,SAFf,kCAE8B,EAAKwE,eAAeM,QAAQiH,uBAAuBnQ,GAAQpD,QAFzF,sBAEOqD,GAFP,cAGO2J,EAAS8C,EAA2B3M,EAAMqQ,eAAepQ,EAAQC,GAASiQ,GAG5ExD,EANL,qBAOO1K,OAAOqO,SAASH,GAPvB,wBAQK1D,EAAU0D,EARf,mCAUyBnQ,EAAMiF,KAAKwH,IAVpC,QAUK8D,EAVL,qCAYWxM,MAAM,mDAAuDoM,IAZxE,gCAeG1D,EAAU,GACV8D,EAAc,GAhBjB,QAyBC,IANM7D,EAAcC,EAClB,EAAK/D,KAAK5I,MAAMI,aAAa,CAACxC,EAAG,QAASD,MAAO8O,EAAQ/M,SAAS,SAAW,GACzE8Q,OAA0BC,IAATP,GAAsC,IAAhBA,EAAKzQ,OAAgB,CAAC,GAAI,IACrEyQ,EAAK,GAAGQ,KAAI,SAACC,EAAKjU,GAAN,OAAYwT,EAAKQ,KAAI,SAACE,GAAD,OAASA,EAAIlU,SAC1CmU,EAAiB7Q,EAAMV,SAAS,EAAKsJ,KAAKiH,IAAIiB,IAAIC,iBAAiBP,EAAc,GAAIA,EAAc,KACnGQ,EAAsB,GACnB7S,EAAI,EAAGA,EAAI0S,EAAepR,OAAQtB,GAAK,EAC9C6S,EAAoBxM,KAAKH,SAASwM,EAAevM,OAAOnG,EAAG,GAAI,KA1BlE,0CA4B2B,EAAKyK,KAAKiH,IAAIoB,kBA5BzC,eA4BOC,EA5BP,0CA6B4B,EAAKC,gBAAgBD,IA7BjD,eA6BOE,EA7BP,OA8BO/E,EAAmB+E,EAAa/E,iBA9BvC,mCA+B2B,EAAKgF,kBAAkBxH,EAAQuH,EAAc,GAAG,IA/B3E,eAgCC9E,GADIA,EA/BL,QAgC+BgF,cAAc1N,OAAO,IAhCpD,EAiCiC,EAAK2N,kBAAkBtR,EAAQC,GAAxDsR,EAjCR,EAiCQA,UAAWC,EAjCnB,EAiCmBA,WAjCnB,6CAmC8C,IAAI3M,SAAQ,SAACC,EAASI,GAC/D,EAAKkJ,OAAOE,QAAQ,yBAChB,CAACjC,cAAeA,EAAeF,WAAYoF,IAAY,SAACrC,EAAKJ,GACvDI,EACFhK,EAAOgK,GAGTpK,EAAQgK,UA1CnB,WAmCS2C,EAnCT,OA6CUpM,EAAcoM,EAAdpM,OAAQqM,EAAMD,EAANC,GACRpF,EAAkCjH,EAAlCiH,oBAAqBqF,EAAatM,EAAbsM,UAStBC,EAAc,2EAClBtF,EAMFuF,GAHIA,EAAaC,KAAUC,QAAQ,KAAKJ,EACpC,EAAKhJ,KAAK5I,MAAMI,aAAa,CAACxC,EAAG,QAASD,MAAOkU,MAE7BP,cAAc1N,OAAO,IAEzC0I,IAAkBwF,EAhEzB,iBAiEKG,QAAQ5M,MAAM,iBAAkBiH,EAAe,uBAAwBwF,GACvExH,EAAQO,KAAKC,EAAmB,CAC9B7N,KAAM,gBACNgO,QAAS,mDAAF,OAAqDqB,EAArD,eAAyEwF,KApEvF,+BAwEWI,EAAalS,EAAMmS,cAAc5F,EAAqBkF,GAEtD1F,EAAc/L,EAAMoS,eAAeF,EAAYjC,GAC/CjE,EAA0BhM,EAAMoS,eAAeF,EAAYjQ,OAAOC,KAAK8O,IACvErO,EAAM,EAAKiG,KAAK5I,MAAMI,aACxB,CAACxC,EAAG,QAASyC,EAAG0L,GAChB,CAACnO,EAAG,QAASyC,EAAG2L,IA9EzB,mCAgF+B,EAAKpD,KAAKiH,IAAIwC,KAAK1P,EAAK1C,IAhFvD,QAgFWuM,EAhFX,OAiFKlC,EAAQO,KAAKC,EAAyB,IAAIgB,GAAKjC,EAAQkC,EAAaC,EAAyBC,EAAUC,EACnGyF,EAAIH,EAAWnF,EAAkBC,EAAeC,EAAqBtM,EAAQuM,EAAatM,EAC1FqQ,EAAY7Q,SAAS,UAAWgN,EAAaC,IAnFtD,2DAsFGrC,EAAQO,KAAKC,EAAb,MAtFH,0DAyFMR,I,uCAaQkF,GAAM,IAEpB,EAFoB,OACflF,EAAU,IAAIC,IA4CpB,OA3CC,mBAAAC,OAAA,yFACuB,EAAK1B,cAAcK,QAAQoC,UAAUiE,EAAKvP,QAAQpD,QADzE,mBAEgB2S,EAAKvD,SAAWuD,EAAKtD,OAFrC,uBAGG5B,EAAQO,KAAKC,EAAmB,CAC9B7N,KAAM,kBACNgO,QAAS,qCALd,mEASO,EAAKnC,cAAcK,QAAQmJ,kBAAkB,EAAKzJ,eAAejK,QAAQ6M,QAC3E+D,EAAKvD,SAAWuD,EAAKtD,OAAOxB,KAAK,CACnCxI,KAAMsN,EAAKvP,UAXd,oBAcmBuP,EAAK7C,yBAdxB,2DAeW,EAAK9D,eAAeM,QAAQoJ,2BAA2B/C,EAAK5C,WAAY4C,EAAKvD,SAC/EuD,EAAKtD,MAAOsD,EAAKnD,iBAAkBmD,EAAKtP,OAAOwK,KAAK,CACtDxI,KAAMsN,EAAKvP,SACV0K,GAAG,mBAAmB,SAACC,GACxB4E,EAAK3C,gBAAkBjC,EACvBN,EAAQO,KAAKC,EAAiDF,MAC7DD,GAAG,gBAAgB,SAACI,EAAoBC,GACzCV,EAAQO,KAAKC,EAA6CC,EAAoBC,OAtBrF,sFAwBW,EAAKnC,eAAeM,QAAQqJ,iBAAiBhD,EAAK5C,WAAY4C,EAAKvD,SAAUuD,EAAKtD,MACpFsD,EAAKnD,kBAAkB3B,KAAK,CAC9BxI,KAAMsN,EAAKvP,SACV0K,GAAG,mBAAmB,SAACC,GACxB4E,EAAK3C,gBAAkBjC,EACvBN,EAAQO,KAAKC,EAAiDF,MAC7DD,GAAG,gBAAgB,SAACI,EAAoBC,GACzCV,EAAQO,KAAKC,EAA6CC,EAAoBC,OA/BrF,4BAcSA,EAdT,KAiCGwE,EAAK1C,OAAS9B,EAAQyH,OAAOC,kBAAkBC,aAAa7F,OAC5D0C,EAAKxE,QAAUA,EACfwE,EAAKzC,UAAY,EACjByC,EAAKvC,oBAAsBjC,EAAQkG,YACnC5G,EAAQO,KAAKC,EAAwCE,GACrDV,EAAQO,KAAKC,GAAgC0E,GAtChD,kDAwCGlF,EAAQO,KAAKC,EAAmB,KAAIG,SAxCvC,yDA2CMX,I,0CASiBkF,G,gIACHvG,KAAKJ,eAAeM,QAAQyJ,cAAcpD,EAAK1C,QAAQjQ,Q,cAAtEyI,E,OACNkK,EAAKzC,UAAY1I,SAASiB,EAAOiE,QACjCiG,EAAKxC,MAAQ1H,EAAO0H,M,kBACbwC,G,+FASqB1C,G,gIACH7D,KAAKJ,eAAeM,QAAQyJ,cAAc9F,GAAQjQ,Q,cAArEgW,E,yBACC,CACL5S,OAAQ4S,EAAW5S,OACnB2M,WAAYiG,EAAWjG,WACvBkG,WAAYD,EAAWC,WACvB7G,SAAU5H,SAASwO,EAAW5G,UAC9BC,MAAO7H,SAASwO,EAAW3G,OAC3BgF,YAAa7M,SAASwO,EAAW3B,aACjC3H,OAAQlF,SAASwO,EAAWtJ,QAC5ByD,MAAO6F,EAAW7F,Q,yFAUEwC,G,0HACRvG,KAAKJ,eAAeM,QAAQyJ,cAAcpD,EAAK1C,QAAQjQ,Q,uCAAQiW,Y,iFAS/DC,G,0HACD9J,KAAKJ,eAAeM,QAAQ6J,UAAUD,GAAWlW,Q,+HAY1CqU,G,4FACgC,IAA/C9T,OAAO6V,KAAKhK,KAAKmG,mBAAmB3P,QACtCyR,EAAcjI,KAAKmG,kBAAkB/C,kBAAoBpD,KAAKiK,W,yDACxCjK,KAAKJ,eAAeM,QAAQgK,eAAetW,Q,cAAlEoM,KAAKiK,U,yCAC+BjK,KAAKJ,eAAeM,QAAQgI,gBAAgBD,GAAarU,Q,OAAvFuW,E,OACNnK,KAAKmG,kBAAoB,CACvB/C,iBAAkBhI,SAAS+O,EAAsB,IACjD9S,KAAMf,IAAKC,OAAO4T,EAAsB,IACxCC,QAASD,EAAsB,GAC/BE,OAAQF,EAAsB,GAAG1C,KAAI,SAAC5O,GAAD,OAAOvC,IAAKC,OAAOsC,O,gCAGrDmH,KAAKmG,mB,yFAYIvF,EAAQ0J,GAA6B,IAArBC,EAAqB,uDAAH,EAE5CC,EAAWF,EAAOD,OAAOI,QAAO,SAACC,EAAGC,GAAJ,OAAUrU,IAAKsU,IAAIF,EAAGC,KAAIrU,IAAKC,OAAO,IACxEU,EAAQ,EACN4T,EAAkB,GACxB,EAAG,CAaD,IAXA,IAAMnR,EAAMmO,aACR,CAAC,UAAW,UAAW,WACvB,CAACyC,EAAOjT,KAAKZ,SAAS,IAAKmK,EAAQ3J,IAEjC0K,EAAOzK,IAAU4T,UAAUpR,GAE7BqR,EAAUzU,IAAK0U,UAAU1U,IAAKC,OAAOoL,GAAO6I,GAC5CS,EAAiBX,EAAOF,QAAQE,EAAOF,QAAQ5T,OAAS,GAInD/C,EAAI,EAAGA,EAAI6W,EAAOF,QAAQ5T,OAAQ/C,IAEzC,IADAsX,EAAUzU,IAAK4U,SAASH,EAAST,EAAOD,OAAO5W,MAChC,EAAG,CAChBwX,EAAiBX,EAAOF,QAAQ3W,GAChC,MAGCoX,EAAgBzJ,SAAS6J,IAC5BJ,EAAgBtP,KAAK0P,GAEvBhU,UAEK4T,EAAgBrU,OAAS+T,GAChC,OAAOM,I,oCAUKtE,GAAM,IAEjB,IAFiB,OACZlF,EAAU,IAAIC,IAuBpB,OAtBC,mBAAAC,OAAA,uDACK4J,EAAkBtJ,GAClBuJ,EAAWvJ,GACX0E,EAAK7C,2BACPyH,EAAkBtJ,GAClBuJ,EAAWvJ,IALd,2CAQS,IAAIhG,SAAQ,SAACC,EAASI,GAC1B,EAAKkJ,OAAOE,QAAQ6F,EAAiB1G,EAAO4G,cAAc9E,IAAO,SAACL,EAAKJ,GACjEI,EACFhK,EAAOgK,GAGTpK,EAAQgK,UAdf,OAiBGzE,EAAQO,KAAKwJ,EAAU7E,GAjB1B,gDAmBGlF,EAAQO,KAAKC,EAAb,MAnBH,wDAsBMR,I,oCAUKkF,GAAM,WACZlF,EAAU,IAAIC,IAEdgK,EAAYxG,KAAMwG,UAAUtL,KAAK6E,OAAOC,OA8C9C,OA7CAwG,EAAUC,SAAQ,SAAOC,GAAP,gCAAAjK,OAAA,kGAEoB,IAAI1F,SAAQ,SAACC,EAASI,GACtD,EAAKkJ,OAAOE,QAAQzD,GAChB,CAACgC,OAAQ9M,EAAMV,SAASkQ,EAAK1C,UAAU,SAACqC,EAAKJ,GACvCI,EACFhK,EAAOgK,GAGTpK,EAAQgK,UATF,YAER2F,EAFQ,QAYUpP,OAZV,sBAaJoP,EAAoBpP,OAAOiE,OAbvB,cAcLuB,GAdK,SAmBLA,GAnBK,UAuBLA,GAvBK,UAwBLA,GAxBK,mBAeR0E,EAAKrC,MAAQuH,EAAoBpP,OAAO6H,MACxCqC,EAAKnC,gBAAkBqH,EAAoBpP,OAAO+H,gBAClDmC,EAAKlC,gBAAkBoH,EAAoBpP,OAAOgI,gBAClDkC,EAAK9C,YAAcgI,EAAoBpP,OAAOoH,YAlBtC,QAoBR8C,EAAKtC,2BAA6BwH,EAAoBpP,OAAOhC,OAC7DkM,EAAKpC,QAAUsH,EAAoBpP,OAAO8H,QAC1CoC,EAAKjC,cAAgBmH,EAAoBpP,OAAOqP,UAtBxC,eAyBRnF,EAAKhC,UAAYkH,EAAoBpP,OAAOiE,OAzBpC,mCA4BD,IAAIxF,MAAM,8BAA+BkH,QA5BxC,oCA+BRsJ,EAAUxG,OAAM,GA/BR,wBAgCVkE,QAAQ2C,IAAI,+CACVH,EAAe,QAAQ,EAAK3G,OAAOC,MAAMC,QAAU,GAAG,iBAjC9C,2BAoCVwB,EAAKhC,UAAY,KApCP,QAuCdlD,EAAQO,KAAKC,GAAoC0E,GAvCnC,kDAyCdlF,EAAQO,KAAKC,EAAb,MAzCc,4DA6CXR,I,wCASSkF,GAAM,IAErB,IAFqB,OAChBlF,EAAU,IAAIC,IAsBpB,OArBC,mBAAAC,OAAA,yFAC+B,EAAK3B,eAAeM,QAAQ0L,qBAAqBhY,QADhF,cACOiY,EADP,yCAE2B,EAAKlM,KAAKiH,IAAIoB,kBAFzC,mBAGmBzB,EAAKvC,qBAAuB6H,GAH/C,uBAIGxK,EAAQO,KAAKC,EAAmB,CAC9B7N,KAAM,oBACNgO,QAAS,qDANd,6EAWyB,EAAKpC,eAAeM,QAAQ4L,kBAAkBvF,EAAK1C,QAAQpC,KAAK,CACpFxI,KAAMsN,EAAKvP,UAZhB,QAWS+K,EAXT,OAcGwE,EAAKzC,UAAYjC,GACjBR,EAAQO,KAAKC,GAA0CE,GACvDV,EAAQO,KAAKC,GAAkC0E,GAhBlD,kDAkBGlF,EAAQO,KAAKC,EAAmB,KAAIG,SAlBvC,yDAqBMX,I,wCASekF,G,kGACtByC,QAAQ2C,IAAI,sCAAsCpF,EAAKtC,4BACnDsC,EAAKtC,4BAA4B,EACdjE,KAAKsI,kBAAkB/B,EAAKvP,OAAQuP,EAAKtP,OAAvDuR,EAD4B,EAC5BA,WACDS,EAAalS,EAAMmS,cAAc3C,EAAKjD,oBAAqBkF,GACjEjC,EAAK/B,gBAAkBzN,EAAMgV,eAAe9C,EAAY1C,EAAKtC,8BAE7D+E,QAAQ2C,IAAI,mFACZpF,EAAK/B,gBAAkB,M,kBAElB+B,G,wFAScA,G,kIACOvG,KAAKgM,kBAAkBzF,I,cAA7C0F,E,OACAC,EAAgBlM,KAAKL,KAAK5I,MAAMI,aAClC,CAACxC,EAAG,QAASD,MAAO6R,EAAKtC,2BAA2BxN,SAAS,S,kBAE1DwV,IAAkBC,G,wFASJ3F,G,gIACIvG,KAAKmM,oBAAoB5F,I,OAA5CzC,E,OAAmDA,U,KACjDyC,EAAKhC,U,cACN1C,G,SAGAA,G,SAGAA,G,UACAA,G,4CANIiC,IAAcjC,I,gCAGdiC,IAAcjC,I,iCAIdiC,IAAcjC,I,iCAGdiC,IAAcjC,I,qHAUP0E,EAAM6F,G,2FAEtB,O,SAAM,IAAIvQ,SAAQ,SAACC,EAASI,GAC1B,EAAKkJ,OAAOE,QAAQzD,GAAiC,CACnDgC,OAAQ9M,EAAMV,SAASkQ,EAAK1C,QAASR,cAAekD,EAAKlD,cACzD+I,WAAYA,IACX,SAAClG,EAAKJ,GACHI,EACFhK,EAAOgK,IAGTK,EAAKhC,UAAYuB,EAASzJ,OAAOiE,OAC7B8L,IACF7F,EAAKtC,2BAA6B6B,EAASzJ,OAAOhC,QAEpDyB,EAAQyK,U,2GAaIA,EAAM8F,EAAWhL,GAAS,WAClCgL,EAAUC,OAClB5X,MAAMmR,MAAK,SAAC9R,GACZsN,EAAQO,KAAKC,GAAqC9N,GAC9B,YAAhBA,EAAEwQ,WAA2C,WAAhBxQ,EAAEwQ,WACjC,EAAKgI,oBAAoBhG,EAAM8F,EAAWhL,MAH9C,OAKS,SAAC6E,GACR7E,EAAQO,KAAKC,EAAmBqE,Q,qCAYrBK,GAA0B,IAApB6F,EAAoB,wDACjC/K,EAAU,IAAIC,IACd+K,EAAYrM,KAAKwM,kBAAkBjG,EAAM6F,GAE/C,OADApM,KAAKuM,oBAAoBhG,EAAM8F,EAAWhL,GACnCA,I,kCAUSkF,G,mGAAMkG,E,+BAAS,I,UACxBlG,EAAKzC,YAAcjC,G,yDACX7B,KAAKmM,oBAAoB5F,I,cAAtCA,E,yCACMxP,EAAM4E,MAAM8Q,I,sDAEblG,G,0FA2BSvP,EAAQC,GAExB,IAGIuR,EAHE3E,EAAS7D,KAAK0M,UAAU1V,EAAQC,GAEhC0V,EAA8B,oBAAXC,OAEnBvV,EAAOsV,EAAYE,KAAKD,OAAOE,aAAaC,QAAQ,SACxD/M,KAAKqG,oBAAL,KAEF,GAAY,MAARhP,EACF,MAAMyD,MAAM,iDAEZ,IAAMkS,EAAW3V,EAAOwM,EAClBjK,EAASlE,IAAMkE,OAAOqT,iBAC5BrT,EAAOsT,aAAe,SAASC,GAC7B,OAAOzX,IAAMoE,KAAKsT,WAAWJ,EAAUG,IAEzC3E,EAAa9S,IAAMoE,KAAKuT,WAAWzT,EAAO0T,SAAS,KAGrD,IAAM/E,EAAYO,KAAUyE,sBAAsB/E,GAKlD,OAHAmE,EAAYC,OAAOE,aAAaU,QAAQ,oBAAoB3J,EAAQ4J,KAAKjF,IACvExI,KAAKqG,oBAAoB,oBAAoBxC,GAAU7K,OAAOC,KAAKuP,EAAY,UAAU/R,SAAS,UAE7F,CAAC8R,YAAWC,gB,uCAUG,IAATnR,EAAS,uDAAJ,GACZsV,EAA8B,oBAAXC,OACzB,GAAa,KAATvV,EAEF,IADA,IAAMqW,EAAa,iEACVja,EAAI,EAAGA,EAAI,EAAGA,IACrB4D,GAAQqW,EAAWC,OAAOC,KAAKC,MAAMD,KAAKhU,SAAW8T,EAAWlX,SAcpE,OAFAmW,EAAYC,OAAOE,aAAaU,QAAQ,OAAQC,KAAKpW,IACnD2I,KAAKqG,oBAAL,KAAmChP,EAC9BA,I,2CAiBY2P,EAAIC,EAAMjE,EAAUC,EAAOjM,EAAQwM,GAAuB,IAE5E,EAF4E,OAAdsK,EAAc,uDAAH,EACpEzM,EAAU,IAAIC,IAmCpB,OAlCC,mBAAAC,OAAA,gDACKwM,EAAa,EADlB,oGAAAxM,OAAA,yFAIwB,IAAI1F,SAAQ,SAACC,EAASI,GACvC,EAAK8R,WAAWhH,EAAIC,EAAMjE,EAAUC,EAAOjM,EAAQwM,GAAS,GACxD9B,GAAGG,GAAyB,SAACxF,GAAD,OAAYP,EAAQO,MAChDqF,GAAGG,GAAmB,SAACzF,GAAD,OAAWF,EAAOE,UAPnD,cAIS6R,EAJT,OASK5M,EAAQO,KAAKC,EAAyBoM,GAT3C,kCAUoB,IAAIpS,SAAQ,SAACC,EAASI,GACnC,EAAKqN,iBAAiB0E,GAClBvM,GAAGG,IAAgC,SAACxF,GAAD,OAAYP,EAAQO,MACvDqF,GAAGG,GAAmB,SAACzF,GAAD,OAAWF,EAAOE,UAbnD,cAUK6R,EAVL,OAeK5M,EAAQO,KAAKC,GAAgCoM,GAflD,mCAgBW,IAAIpS,SAAQ,SAACC,EAASI,GAC1B,EAAKgS,cAAcD,GACfvM,GAAGG,IAA2C,SAACE,GAAD,OAAajG,EAAQiG,MACnEL,GAAGG,GAAmB,SAACzF,GAAD,OAAWF,EAAOE,UAnBnD,eAqBKiF,EAAQO,KAAKC,GAA2CoM,GArB7D,0MAwBUF,KAAgBD,GACT,gGAAR,MACO,2HAAR,MA1BR,wBA4BOzM,EAAQO,KAAKC,EAAb,MA5BP,qGAkCMR,I,kCAgBG2F,EAAIC,EAAMjE,EAAUC,EAAOjM,EAAQ4J,GAAsB,IAElE,EAFkE,OAAdkN,EAAc,uDAAH,EAC1DzM,EAAU,IAAIC,IAiCpB,OAhCC,mBAAAC,OAAA,gDACKwM,EAAa,EADlB,oGAAAxM,OAAA,yFAIsB,IAAI1F,SAAQ,SAACC,EAASI,GACrC,EAAK8R,WAAWhH,EAAIC,EAAMjE,EAAUC,EAAOjM,EAAQ4J,GAAQ,GACvDc,GAAGG,GAAyB,SAACxF,GAAD,OAAYP,EAAQO,MAChDqF,GAAGG,GAAmB,SAACzF,GAAD,OAAWF,EAAOE,UAPnD,cAISmK,EAJT,OASKlF,EAAQO,KAAKC,EAAyB0E,GAT3C,kCAUkB,IAAI1K,SAAQ,SAACC,EAASI,GACjC,EAAKqN,iBAAiBhD,GAClB7E,GAAGG,IAAgC,SAACxF,GAAD,OAAYP,EAAQO,MACvDqF,GAAGG,GAAmB,SAACzF,GAAD,OAAWF,EAAOE,UAbnD,cAUKmK,EAVL,OAeKlF,EAAQO,KAAKC,GAAgC0E,GAflD,mCAgBW,IAAI1K,SAAQ,SAACC,EAASI,GAC1B,EAAKgS,cAAc3H,GACf7E,GAAGG,IAAoC,SAACE,GAAD,OAAajG,EAAQiG,MAC5DL,GAAGG,GAAmB,SAACzF,GAAD,OAAWF,EAAOE,UAnBnD,eAqBKiF,EAAQO,KAAKC,GAAoC0E,GArBtD,0MAwBUwH,KAAgBD,GACV,gGAAR,MAzBR,wBA0BOzM,EAAQO,KAAKC,EAAb,MA1BP,qGAgCMR,I,gCAUCrK,EAAQC,GAChB,OAAO+I,KAAKL,KAAK5I,MAAMI,aAAa,CAACxC,EAAG,UAAWyC,EAAGJ,GAAS,CAACrC,EAAG,UAAWyC,EAAGH,S,kCC9zBrF","file":"enigma-js.node.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"enigma-js\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"enigma-js\"] = factory();\n\telse\n\t\troot[\"enigma-js\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","module.exports = require(\"node-forge\");","module.exports = require(\"eventemitter3\");","module.exports = require(\"jsbi\");","module.exports = require(\"web3-utils\");","module.exports = require(\"buffer\");","module.exports = require(\"zlib\");","module.exports = require(\"eth-crypto\");","module.exports = require(\"elliptic\");","module.exports = require(\"jayson/lib/client/browser\");","module.exports = require(\"axios\");","module.exports = require(\"retry\");","module.exports = require(\"ethereumjs-abi\");","module.exports = require(\"core-js/stable\");","module.exports = require(\"regenerator-runtime/runtime\");","import JSBI from 'jsbi';\nimport web3Utils from 'web3-utils';\n// import RLP from 'rlp';\nimport forge from 'node-forge';\nimport elliptic from 'elliptic';\nimport {Buffer} from 'buffer';\nimport zlib from 'zlib';\n\nforge.options.usePureJavaScript = true;\n\nconst EC = elliptic.ec;\n\n// const pki = forge.pki;\n\n// const INTEL_CA = '-----BEGIN CERTIFICATE-----\\n' +\n//   'MIIFSzCCA7OgAwIBAgIJANEHdl0yo7CUMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNV\\n' +\n//   'BAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwLU2FudGEgQ2xhcmExGjAYBgNV\\n' +\n//   'BAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQDDCdJbnRlbCBTR1ggQXR0ZXN0\\n' +\n//   'YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwIBcNMTYxMTE0MTUzNzMxWhgPMjA0OTEy\\n' +\n//   'MzEyMzU5NTlaMH4xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwL\\n' +\n//   'U2FudGEgQ2xhcmExGjAYBgNVBAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQD\\n' +\n//   'DCdJbnRlbCBTR1ggQXR0ZXN0YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwggGiMA0G\\n' +\n//   'CSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQCfPGR+tXc8u1EtJzLA10Feu1Wg+p7e\\n' +\n//   'LmSRmeaCHbkQ1TF3Nwl3RmpqXkeGzNLd69QUnWovYyVSndEMyYc3sHecGgfinEeh\\n' +\n//   'rgBJSEdsSJ9FpaFdesjsxqzGRa20PYdnnfWcCTvFoulpbFR4VBuXnnVLVzkUvlXT\\n' +\n//   'L/TAnd8nIZk0zZkFJ7P5LtePvykkar7LcSQO85wtcQe0R1Raf/sQ6wYKaKmFgCGe\\n' +\n//   'NpEJUmg4ktal4qgIAxk+QHUxQE42sxViN5mqglB0QJdUot/o9a/V/mMeH8KvOAiQ\\n' +\n//   'byinkNndn+Bgk5sSV5DFgF0DffVqmVMblt5p3jPtImzBIH0QQrXJq39AT8cRwP5H\\n' +\n//   'afuVeLHcDsRp6hol4P+ZFIhu8mmbI1u0hH3W/0C2BuYXB5PC+5izFFh/nP0lc2Lf\\n' +\n//   '6rELO9LZdnOhpL1ExFOq9H/B8tPQ84T3Sgb4nAifDabNt/zu6MmCGo5U8lwEFtGM\\n' +\n//   'RoOaX4AS+909x00lYnmtwsDVWv9vBiJCXRsCAwEAAaOByTCBxjBgBgNVHR8EWTBX\\n' +\n//   'MFWgU6BRhk9odHRwOi8vdHJ1c3RlZHNlcnZpY2VzLmludGVsLmNvbS9jb250ZW50\\n' +\n//   'L0NSTC9TR1gvQXR0ZXN0YXRpb25SZXBvcnRTaWduaW5nQ0EuY3JsMB0GA1UdDgQW\\n' +\n//   'BBR4Q3t2pn680K9+QjfrNXw7hwFRPDAfBgNVHSMEGDAWgBR4Q3t2pn680K9+Qjfr\\n' +\n//   'NXw7hwFRPDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADANBgkq\\n' +\n//   'hkiG9w0BAQsFAAOCAYEAeF8tYMXICvQqeXYQITkV2oLJsp6J4JAqJabHWxYJHGir\\n' +\n//   'IEqucRiJSSx+HjIJEUVaj8E0QjEud6Y5lNmXlcjqRXaCPOqK0eGRz6hi+ripMtPZ\\n' +\n//   'sFNaBwLQVV905SDjAzDzNIDnrcnXyB4gcDFCvwDFKKgLRjOB/WAqgscDUoGq5ZVi\\n' +\n//   'zLUzTqiQPmULAQaB9c6Oti6snEFJiCQ67JLyW/E83/frzCmO5Ru6WjU4tmsmy8Ra\\n' +\n//   'Ud4APK0wZTGtfPXU7w+IBdG5Ez0kE1qzxGQaL4gINJ1zMyleDnbuS8UicjJijvqA\\n' +\n//   '152Sq049ESDz+1rRGc2NVEqh1KaGXmtXvqxXcTB+Ljy5Bw2ke0v8iGngFBPqCTVB\\n' +\n//   '3op5KBG3RjbF6RRSzwzuWfL7QErNC8WEy5yDVARzTA5+xmBc388v9Dm21HGfcC8O\\n' +\n//   'DD+gT9sSpssq0ascmvH49MOgjt1yoysLtdCtJW/9FZpoOypaHx0R+mJTLwPXVMrv\\n' +\n//   'DaVzWh5aiEx+idkSGMnX\\n' +\n//   '-----END CERTIFICATE-----';\n\n// /**\n//  * Serialize the pem cert.\n//  *\n//  * @param {string} pem\n//  * @return {*}\n//  */\n// function readCert(pem) {\n//   let cert;\n//\n//   try {\n//     cert = pki.certificateFromPem(pem);\n//   } catch (e) {\n//     return {\n//       verified: false,\n//       err: 'Failed to load report certificate : ' + e,\n//     };\n//   }\n//   return cert;\n// }\n\n// /**\n//  * Parse the signer's address from the quote\n//  *\n//  * @param {string} reportContent\n//  * @return {string}\n//  */\n// function parseAddress(reportContent) {\n//   const report = JSON.parse(reportContent);\n//   let b = new Buffer(report.isvEnclaveQuoteBody, 'base64');\n//\n//   return b.slice(368, 410).toString();\n// }\n\n// /**\n//  * Verifies that the worker signer address is associated to an authentic SGX report\n//  *\n//  * @param {string} signer\n//  * @param {string} encodedReport\n//  * @return {*}\n//  */\n// function verifyWorker(signer, encodedReport) {\n//   const reportArgs = RLP.decode(encodedReport);\n//   // console.log ('decoding report\\n', reportArgs[0], '\\n', reportArgs[1], '\\n', reportArgs[2]);\n//   const report = reportArgs[0].toString('utf8');\n//\n//   if (report === 'simulation') {\n//     return {\n//       verified: true,\n//       err: 'Running in simulation mode',\n//     };\n//   }\n//\n//   const reportCert = reportArgs[1].toString('utf8');\n//   const reportSig = reportArgs[2];\n//   const cert = readCert(reportCert);\n//   let md = forge.md.sha256.create();\n//\n//   md.update(report, 'utf8');\n//\n//   try {\n//     // verify data with a public key\n//     // (defaults to RSASSA PKCS#1 v1.5)\n//     // TODO: verify that the public key belongs to the signer\n//     const verified = cert.publicKey.verify(md.digest().bytes(), reportSig);\n//\n//     if (!verified) {\n//       return {\n//         verified: false,\n//         err: 'The signature does not match the signed report',\n//       };\n//     }\n//   } catch (e) {\n//     return {\n//       verified: false,\n//       err: 'Failed to verify the report signature: ' + e,\n//     };\n//   }\n//\n//   let caStore;\n//\n//   try {\n//     caStore = pki.createCaStore([INTEL_CA]);\n//   } catch (e) {\n//     return {\n//       verified: false,\n//       err: 'Failed to load CA certificate: ' + e,\n//     };\n//   }\n//\n//   try {\n//     pki.verifyCertificateChain(caStore, [cert]);\n//   } catch (e) {\n//     return {\n//       verified: false,\n//       err: 'Failed to verify certificate: ' + e,\n//     };\n//   }\n//\n//   const address = parseAddress(report);\n//\n//   if (address !== signer) {\n//     return {\n//       verified: false,\n//       err: 'Signer address does not match the report: ' + signer + ' != ' +\n//         address,\n//     };\n//   }\n//\n//   return {verified: true, err: undefined};\n// }\n\n// /**\n//  * Encode secret contract function arguments\n//  *\n//  * @param {Object} args\n//  * @return {string}\n//  */\n// function encodeArguments(args) {\n//   return '0x' + RLP.encode(args).toString('hex');\n// }\n\n/**\n * Generate a taskId using a hash of all inputs\n * The Enigma contract uses the same logic to generate a matching taskId\n *\n * @param {string} sender\n * @param {Number} nonce\n * @return {string}\n */\nfunction generateScAddr(sender, nonce) {\n  return web3Utils.soliditySha3(\n      {t: 'bytes', v: sender},\n      {t: 'uint', v: nonce},\n  );\n}\n\n/**\n * Generate a taskId using a hash of all inputs\n * The Enigma contract uses the same logic to generate a matching taskId\n *\n * @param {string} hexStr - Buffer being appended to\n * @param {Array} inputsArray - Array of inputs\n * @param {boolean} principal - Principal hashing\n * @return {string} - Final appended hex string\n */\nfunction appendMessages(hexStr, inputsArray, principal=false) {\n  const principalPrefix = principal ? '00' : '';\n  for (let input of inputsArray) {\n    input = remove0x(input);\n    // since the inputs are in hex string, they are twice as long as their bytes\n    hexStr += principalPrefix + JSBI.BigInt(input.length/2).toString(16).padStart(16, '0') + input;\n  }\n  return hexStr;\n}\n\n/**\n * Generate a hash of an array containing an array of inputs\n *\n * @param {string} hexStr - Buffer being appended to\n * @param {Array} inputsArray - Array of array of inputs\n * @param {boolean} principal - Principal hashing\n * @return {string} - Final appended hex string\n */\nfunction appendArrayMessages(hexStr, inputsArray) {\n  const principalPrefix = '01';\n  for (const array of inputsArray) {\n    hexStr += principalPrefix + JSBI.BigInt(array[0].length * (array[1]+9)).toString(16).padStart(16, '0');\n    hexStr = appendMessages(hexStr, array[0], true);\n  }\n  return hexStr;\n}\n\n/**\n * Generate a hash of all inputs\n *\n * @param {array} inputsArray - Array of inputs\n * @return {string} Hash of inputs\n */\nfunction hash(inputsArray) {\n  const hexStr = appendMessages('', inputsArray);\n  return web3Utils.soliditySha3({t: 'bytes', v: hexStr});\n}\n\n/**\n * Generate a hash of inputs for setting the worker params from the principal node\n *\n * @param {Number} seed - The random integer generated by the enclave\n * @param {Number} nonce - Nonce value for principal node\n * @param {Array} workerAddresses - Worker signing addresses\n * @param {Array} workerStakes - Worker stake balances\n * @return {string} Hash of inputs\n */\nfunction principalHash(seed, nonce, workerAddresses, workerStakes) {\n  let hexStr = '';\n  hexStr = appendMessages(hexStr, [seed, nonce], true);\n  hexStr = appendArrayMessages(hexStr, [[workerAddresses, 20], [workerStakes, 32]]);\n  return web3Utils.soliditySha3({t: 'bytes', v: hexStr});\n}\n\n/**\n * Generate a hash of inputs necessary for commit multiple receipts logic\n *\n * @param {string} codeHash\n * @param {Array} inputsHashes\n * @param {string} lastStateDeltaHash\n * @param {Array} stateDeltaHashes\n * @param {Array} outputHashes\n * @param {Array} gasesUsed\n * @param {string} optionalEthereumData\n * @param {string} optionalEthereumContractAddress\n * @param {string} successFlag\n * @return {string} hash of inputs\n */\nfunction commitReceiptsHash(codeHash, inputsHashes, lastStateDeltaHash, stateDeltaHashes, outputHashes, gasesUsed,\n    optionalEthereumData, optionalEthereumContractAddress, successFlag) {\n  let hexStr = '';\n  hexStr = appendMessages(hexStr, [codeHash]);\n  hexStr = appendArrayMessages(hexStr, [inputsHashes]);\n  hexStr = appendMessages(hexStr, [lastStateDeltaHash]);\n  hexStr = appendArrayMessages(hexStr, [stateDeltaHashes, outputHashes, gasesUsed]);\n  hexStr = appendMessages(hexStr, [optionalEthereumData, optionalEthereumContractAddress, successFlag]);\n\n  return web3Utils.soliditySha3({t: 'bytes', v: hexStr});\n}\n\n// /**\n//  * RLP encode report parts\n//  *\n//  * @param {string} report\n//  * @param {string} cert\n//  * @param {string} sig\n//  * @return {string}\n//  */\n// function encodeReport(report, cert, sig) {\n//   return '0x' + RLP.encode([report, cert, sig]).toString('hex');\n// }\n\n// /**\n//  * Verifies that the specified method signature matches the specs defined\n//  * by the Ethereum abi: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n//  *\n//  * @param {string} methodSig\n//  * @return {boolean}\n//  */\n// function checkMethodSignature(methodSig) {\n//   const rx = /\\b\\((.*?)\\)/g;\n//   const result = rx.test(methodSig);\n//\n//   return result;\n// }\n\n// /**\n//  * Generate an Ethereum-like address from a public key\n//  *\n//  * @param {string} publicKey\n//  * @return {string}\n//  */\n// function toAddress(publicKey) {\n//   const address = EthCrypto.publicKey.toAddress(publicKey);\n//\n//   return address;\n// }\n\n// /**\n//  * Sign a message with the specified private key\n//  *\n//  * @param {string} privateKey\n//  * @param {string} message\n//  * @return {string}\n//  */\n// function sign(privateKey, message) {\n//   return EthCrypto.sign(\n//     privateKey,\n//     message,\n//   );\n// }\n\n// /**\n//  * Returns the address with which the message was signed\n//  *\n//  * @param {string} signature\n//  * @param {string} message\n//  * @return {string}\n//  */\n// function recover(signature, message) {\n//   return EthCrypto.recover(\n//     signature,\n//     message,\n//   );\n// }\n\n// /**\n//  * Returns the public key associated with the message signature\n//  *\n//  * @param {string} signature\n//  * @param {string} message\n//  * @return {string} Public key\n//  */\n// function recoverPublicKey(signature, message) {\n//   return EthCrypto.recoverPublicKey(\n//     signature,\n//     message,\n//   );\n// }\n\n/**\n * This does ECDH key derivation from 2 EC secp256k1 keys.\n * It does so by multiplying the public points by the private point of the over key.\n * This results in a X and Y. it then replaces the Y with 0x02 if Y is even and 0x03 if it's odd.\n * Then it hashes the new Y together with the X using SHA256.\n * Multiplication: https://github.com/indutny/elliptic/blob/master/lib/elliptic/ec/key.js#L104\n * Replacing Y: https://source.that.world/source/libsecp256k1-rs/browse/master/src/ecdh.rs$25\n *\n * @param {string} enclavePublicKey\n * @param {string} clientPrivateKey\n * @return {string}\n */\nfunction getDerivedKey(enclavePublicKey, clientPrivateKey) {\n  const ec = new EC('secp256k1');\n\n  if (enclavePublicKey.length == 128) {\n    enclavePublicKey = '04' + enclavePublicKey;\n  }\n\n  const clientKey = ec.keyFromPrivate(clientPrivateKey, 'hex');\n  const enclaveKey = ec.keyFromPublic(enclavePublicKey, 'hex');\n\n  const sharedPoints = enclaveKey.getPublic().mul(clientKey.getPrivate());\n  const y = 0x02 | (sharedPoints.getY().isOdd() ? 1 : 0);\n  const x = sharedPoints.getX();\n  const yBuffer = Buffer.from([y]);\n  const xBuffer = x.toArrayLike(Buffer, 'be', 32);\n\n  const sha256 = forge.md.sha256.create();\n\n  sha256.update(yBuffer.toString('binary'));\n  sha256.update(xBuffer.toString('binary'));\n\n  return sha256.digest().toHex();\n}\n\n/**\n * Decrypts the encrypted message:\n * Message format: encrypted_message[*]tag[16]iv[12] (represented as: var_name[len])\n *\n * @param {string} keyHex - Derived key\n * @param {string} msgHex - Encrypted message\n * @return {string} Decrypted message\n */\nfunction decryptMessage(keyHex, msgHex) {\n  const key = forge.util.hexToBytes(keyHex);\n  const msgBuf = Buffer.from(msgHex, 'hex');\n  const iv = forge.util.createBuffer(msgBuf.slice(-12));\n  const tag = forge.util.createBuffer(msgBuf.slice(-28, -12));\n  const decipher = forge.cipher.createDecipher('AES-GCM', key);\n\n  decipher.start({iv: iv, tag: tag});\n  decipher.update(\n      forge.util.createBuffer(msgBuf.slice(0, -28)));\n\n  if (decipher.finish()) {\n    return decipher.output.toHex();\n  }\n  throw new Error('decipher did not finish');\n}\n\n/**\n * Encrypts a message using the provided key.\n * Returns an encrypted message in this format:\n * encrypted_message[*]tag[16]iv[12] (represented as: var_name[len])\n *\n * @param {string} keyHex - Derived key\n * @param {string} msg - Unencrypted message\n * @param {string} iv\n * @return {string} Encrypted message\n */\nfunction encryptMessage(keyHex, msg, iv = forge.random.getBytesSync(12)) {\n  const key = forge.util.hexToBytes(keyHex);\n  const cipher = forge.cipher.createCipher('AES-GCM', key);\n\n  cipher.start({iv: iv});\n  cipher.update(forge.util.createBuffer(msg));\n  cipher.finish();\n\n  const result = cipher.output.putBuffer(cipher.mode.tag).putBytes(iv);\n\n  return result.toHex();\n}\n\n/**\n * Converts ENG value to grains format.\n *\n * @param {int} engValue\n * @return {int} ENG value in grains format\n */\nfunction toGrains(engValue) {\n  return engValue * 10**8;\n}\n\n// /**\n//  * Converts grains format to ENG value.\n//  *\n//  * @param {int} grains\n//  * @return {int}\n//  */\n// function fromGrains(grains) {\n//   return grains / 10**8;\n// }\n\n/**\n * Removes '0x' from a hex string, if present\n *\n * @param {string} hexString\n * @return {string}\n */\nfunction remove0x(hexString) {\n  if (hexString.substring(0, 2) == '0x') {\n    return hexString.substring(2);\n  } else {\n    return hexString;\n  }\n}\n\n/**\n * Converts a hex string to its ASCII representation\n *\n * @param {string} hexString\n * @return {string}\n */\nfunction hexToAscii(hexString) {\n  if (!(typeof hexString === 'number' || typeof hexString == 'string')) {\n    return '';\n  }\n  hexString = hexString.toString().replace(/\\s+/gi, '');\n  const stack = [];\n  for (let n = 0; n < hexString.length; n += 2) {\n    const code = parseInt(hexString.substr(n, 2), 16);\n    if (!isNaN(code) && code !== 0) {\n      stack.push(String.fromCharCode(code));\n    }\n  }\n  return stack.join('');\n}\n\n/**\n * Sleeps\n *\n * @param {int} ms\n * @return {undefined}\n */\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/** Compress using GZIP\n *  @param {Buffer} buffer to compress\n *  @return {Promise}\n * */\nfunction gzip(buffer) {\n  return new Promise((resolve, reject)=> {\n    zlib.gzip(buffer, (error, result)=>{\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n\n/** Unzip using GZIP\n *  @param {Buffer} buffer compressed\n *  @return {Promise}\n * */\nfunction gunzip(buffer) {\n  return new Promise((resolve, reject) => {\n    zlib.gunzip(buffer, (error, result) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n\n\nconst utils = {};\n\n// utils.readCert = readCert;\n// utils.encodeReport = encodeReport;\nutils.test = () => 'hello2';\n// utils.encodeArguments = encodeArguments;\nutils.generateScAddr = generateScAddr;\nutils.hash = hash;\nutils.principalHash = principalHash;\nutils.commitReceiptsHash = commitReceiptsHash;\n// utils.verifyWorker = verifyWorker;\n// utils.checkMethodSignature = checkMethodSignature;\n// utils.toAddress = toAddress;\n// utils.sign = sign;\n// utils.recover = recover;\n// utils.recoverPublicKey = recoverPublicKey;\nutils.getDerivedKey = getDerivedKey;\nutils.encryptMessage = encryptMessage;\nutils.decryptMessage = decryptMessage;\nutils.toGrains = toGrains;\n// utils.fromGrains = fromGrains;\nutils.remove0x = remove0x;\nutils.hexToAscii = hexToAscii;\nutils.sleep = sleep;\nutils.gzip = gzip;\nutils.gunzip = gunzip;\n\nexport default utils;\n","export const ERROR = 'error';\nexport const DEPOSIT_TRANSACTION_HASH = 'depositTransactionHash';\nexport const DEPOSIT_CONFIRMATION = 'depositConfirmation';\nexport const DEPOSIT_RECEIPT = 'depositReceipt';\nexport const WITHDRAW_TRANSACTION_HASH = 'withdrawTransactionHash';\nexport const WITHDRAW_CONFIRMATION = 'withdrawConfirmation';\nexport const WITHDRAW_RECEIPT = 'withdrawReceipt';\nexport const LOGIN_TRANSACTION_HASH = 'loginTransactionHash';\nexport const LOGIN_CONFIRMATION = 'loginConfirmation';\nexport const LOGIN_RECEIPT = 'loginReceipt';\nexport const LOGOUT_TRANSACTION_HASH = 'logoutTransactionHash';\nexport const LOGOUT_CONFIRMATION = 'logoutConfirmation';\nexport const LOGOUT_RECEIPT = 'logoutReceipt';\nexport const UNREGISTER_TRANSACTION_HASH = 'unregisterTransactionHash';\nexport const UNREGISTER_CONFIRMATION = 'unregisterConfirmation';\nexport const UNREGISTER_RECEIPT = 'unregisterReceipt';\nexport const SET_OPERATING_ADDRESS_TRANSACTION_HASH = 'setOperatingAddressTransactionHash';\nexport const SET_OPERATING_ADDRESS_CONFIRMATION = 'setOperatingAddressConfirmation';\nexport const SET_OPERATING_ADDRESS_RECEIPT = 'setOperatingAddressReceipt';\n\nexport const DEPLOY_SC_ADDR_RESULT = 'deploySCAddrResult';\nexport const DEPLOY_SC_ETH_TRANSACTION_HASH = 'deploySCEthTransactionHash';\nexport const DEPLOY_SC_ETH_CONFIRMATION = 'deploySCEthConfirmation';\nexport const DEPLOY_SC_ETH_RECEIPT = 'deploySCEthReceipt';\nexport const DEPLOY_SC_ENG_RECEIPT = 'deploySCEngReceipt';\n\nexport const CREATE_TASK = 'createTask';\nexport const CREATE_TASK_INPUT = 'createTaskInput';\nexport const CREATE_TASK_RECORD_TRANSACTION_HASH = 'createTaskRecordTransactionHash';\nexport const CREATE_TASK_RECORD_CONFIRMATION = 'createTaskRecordConfirmation';\nexport const CREATE_TASK_RECORD_RECEIPT = 'createTaskRecordReceipt';\nexport const CREATE_TASK_RECORD = 'createTaskRecord';\n\nexport const SEND_TASK_INPUT_RESULT = 'sendTaskInputResult';\nexport const POLL_TASK_STATUS_RESULT = 'pollTaskStatusResult';\nexport const GET_TASK_RESULT_RESULT = 'getTaskResultResult';\nexport const DEPLOY_SECRET_CONTRACT_RESULT = 'deploySecretContractResult';\n\nexport const RETURN_FEES_FOR_TASK_RECEIPT = 'returnFeesForTaskReceipt';\nexport const RETURN_FEES_FOR_TASK = 'returnFeesForTask';\n\nexport const POLL_TASK_ETH_RESULT = 'pollTaskETHResult';\n\nexport const RPC_SEND_TASK_INPUT = 'sendTaskInput';\nexport const RPC_DEPLOY_SECRET_CONTRACT = 'deploySecretContract';\nexport const RPC_GET_TASK_RESULT = 'getTaskResult';\nexport const RPC_GET_TASK_STATUS = 'getTaskStatus';\nexport const GET_TASK_RESULT_SUCCESS = 'SUCCESS';\nexport const GET_TASK_RESULT_FAILED = 'FAILED';\nexport const GET_TASK_RESULT_UNVERIFIED = 'UNVERIFIED';\nexport const GET_TASK_RESULT_INPROGRESS = 'INPROGRESS';\n\nexport const ETH_STATUS_UNDEFINED = 0;\nexport const ETH_STATUS_CREATED = 1;\nexport const ETH_STATUS_VERIFIED = 2;\nexport const ETH_STATUS_FAILED = 3;\nexport const ETH_STATUS_FAILED_ETH = 4;\nexport const ETH_STATUS_FAILED_RETURN = 5;\n","import EventEmitter from 'eventemitter3';\nimport * as eeConstants from './emitterConstants';\n\n/**\n * Encapsulates the admin operations\n */\nexport default class Admin {\n  /**\n   * Constructor\n   * @param {Web3} web3 - Web3 provider for the library\n   * @param {Web3.Contract} enigmaContract - Enigma contract deployed to Ethereum\n   * @param {Web3.Contract} tokenContract - Enigma token contract deployed to Ethereum\n   * @param {Object} txDefaults\n   * @param {Enigma} enigma - Enigma wrapper instance\n   */\n  constructor(web3, enigmaContract, tokenContract, txDefaults, enigma) {\n    this.web3 = web3;\n    this.enigmaContract = enigmaContract;\n    this.tokenContract = tokenContract;\n    this.txDefaults = txDefaults;\n    this.enigma = enigma;\n  }\n\n  /**\n   * Find worker by signing address\n   *\n   * @param {string} sigAddr - The signing address\n   * @return {Promise} Resolves to worker's details\n   */\n  async findBySigningAddress(sigAddr) {\n    const result = await this.enigmaContract.methods.getWorkerFromSigningAddress(sigAddr).call();\n    return {\n      account: result[0],\n      stakingAddress: result[1][0],\n      status: parseInt(result[1][2]),\n      report: result[1][3],\n      balance: parseInt(result[1][4]),\n      logs: result[1][5],\n    };\n  }\n\n  /**\n   * Get the worker's status\n   *\n   * @param {string} account - Worker's ETH address\n   * @return {Promise} Resolves to status of worker (0=Unregistered, 1=LoggedIn, 2=LoggedOut)\n   */\n  async getWorkerStatus(account) {\n    const worker = await this.enigmaContract.methods.getWorker(account).call();\n    return parseInt(worker.status);\n  }\n\n  /**\n   * Checks if a secret contract is deployed\n   *\n   * @param {string} scAddr - Secret contract address\n   * @return {Promise} Resolves to a boolean value whether the contract has been deployed or not\n   */\n  async isDeployed(scAddr) {\n    return parseInt((await this.enigmaContract.methods.getSecretContract(scAddr).call()).status) === 1;\n  }\n\n  /**\n   * Count the number of deployed secret contracts.\n   *\n   * @return {Promise} - Resolves to number of deployed secret contracts\n   */\n  async countSecretContracts() {\n    return parseInt(await this.enigmaContract.methods.countSecretContracts().call());\n  }\n\n  /**\n   * Get the addresses of deployed secret contracts within a specified range.\n   *\n   * @param {number} start - Start index of secret contract address to retrieve (inclusive)\n   * @param {number} stop - Stop index of secret contract address to retrieve (exclusive)\n   * @return {Promise} - Resolves to the addresses of deployed secret contracts within range\n   */\n  async getSecretContractAddresses(start, stop) {\n    return (await this.enigmaContract.methods.getSecretContractAddresses(start, stop).call());\n  }\n\n  /**\n   * Get the addresses of all deployed secret contracts.\n   *\n   * @return {Promise} - Resolves to the addresses of deployed secret contracts within range\n   */\n  async getAllSecretContractAddresses() {\n    return (await this.enigmaContract.methods.getAllSecretContractAddresses().call());\n  }\n\n  /**\n   * Fetches the secret contract bytecode hash\n   *\n   * @param {string} scAddr - Secret contract address\n   * @return {Promise} - Resolves to the bytecode hash of the deployed secret contract\n   */\n  async getCodeHash(scAddr) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).codeHash;\n  }\n\n  /**\n   * Count the state deltas for the specified secret contract.\n   *\n   * @param {string} scAddr - Secret contract address\n   * @return {Promise} - Resolves to count of state deltas\n   */\n  async countStateDeltas(scAddr) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).stateDeltaHashes.length;\n  }\n\n  /**\n   * Fetch the state delta hash at the specified index position\n   *\n   * @param {string} scAddr - Secret contract address\n   * @param {number} index - Index of state delta hash to retrieve\n   * @return {Promise} - Resolves to state delta hash at the specified position\n   */\n  async getStateDeltaHash(scAddr, index) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).stateDeltaHashes[index];\n  }\n\n  /**\n   * Fetch state delta hashes in the specified range\n   *\n   * @param {string} scAddr - Secret contract address\n   * @param {number} start - Start index of state delta hash to retrieve (inclusive)\n   * @param {number} stop - Stop index of state delta hash to retrieve (exclusive)\n   * @return {Promise} - Resolves to the state delta hashes in the specified range\n   */\n  async getStateDeltaHashes(scAddr, start, stop) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).stateDeltaHashes.slice(start, stop);\n  }\n\n  /**\n   * Check that the specified state delta hash is valid.\n   *\n   * @param {string} scAddr - Secret contract address\n   * @param {string} stateDeltaHash - State delta hash for a given task\n   * @return {Promise} Resolves to boolean value for whether the state delta hash is valid\n   */\n  async isValidDeltaHash(scAddr, stateDeltaHash) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).stateDeltaHashes.includes(\n        stateDeltaHash);\n  }\n\n  /**\n   * Login the selected worker\n   *\n   * @param {string} account - ETH address for worker being logged in\n   * @return {EventEmitter} EventEmitter to be listened to track login transaction\n   */\n  login(account) {\n    const emitter = new EventEmitter();\n    (async () => {\n      try {\n        await this.enigmaContract.methods.login().send({from: account}).on('transactionHash', (hash) => {\n          emitter.emit(eeConstants.LOGIN_TRANSACTION_HASH, hash);\n        }).on('confirmation', (confirmationNumber, receipt) => {\n          emitter.emit(eeConstants.LOGIN_CONFIRMATION, confirmationNumber, receipt);\n        }).on('receipt', (receipt) => {\n          emitter.emit(eeConstants.LOGIN_RECEIPT, receipt);\n        });\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Set operating address for a staking address\n   *\n   * @param {string} stakingAddress - Staking address\n   * @param {string} operatingAddress - Operating address\n   * @return {EventEmitter} EventEmitter to be listened to track login transaction\n   */\n  setOperatingAddress(stakingAddress, operatingAddress) {\n    const emitter = new EventEmitter();\n    (async () => {\n      try {\n        await this.enigmaContract.methods.setOperatingAddress(operatingAddress).send({\n          from: stakingAddress,\n        }).on('transactionHash', (hash) => {\n          emitter.emit(eeConstants.SET_OPERATING_ADDRESS_TRANSACTION_HASH, hash);\n        }).on('confirmation', (confirmationNumber, receipt) => {\n          emitter.emit(eeConstants.SET_OPERATING_ADDRESS_CONFIRMATION, confirmationNumber, receipt);\n        }).on('receipt', (receipt) => {\n          emitter.emit(eeConstants.SET_OPERATING_ADDRESS_RECEIPT, receipt);\n        });\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Logout the selected worker\n   *\n   * @param {string} account - ETH address for worker being logged out\n   * @return {EventEmitter} EventEmitter to be listened to track logout transaction\n   */\n  logout(account) {\n    const emitter = new EventEmitter();\n    (async () => {\n      try {\n        await this.enigmaContract.methods.logout().send({from: account}).on('transactionHash', (hash) => {\n          emitter.emit(eeConstants.LOGOUT_TRANSACTION_HASH, hash);\n        }).on('confirmation', (confirmationNumber, receipt) => {\n          emitter.emit(eeConstants.LOGOUT_CONFIRMATION, confirmationNumber, receipt);\n        }).on('receipt', (receipt) => {\n          emitter.emit(eeConstants.LOGOUT_RECEIPT, receipt);\n        });\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Unregister the selected worker\n   *\n   * @param {string} account - ETH staking address or operating address\n   * @return {EventEmitter} EventEmitter to be listened to track logout transaction\n   */\n  unregister(account) {\n    const emitter = new EventEmitter();\n    (async () => {\n      try {\n        await this.enigmaContract.methods.unregister().send({from: account}).on('transactionHash', (hash) => {\n          emitter.emit(eeConstants.UNREGISTER_TRANSACTION_HASH, hash);\n        }).on('confirmation', (confirmationNumber, receipt) => {\n          emitter.emit(eeConstants.UNREGISTER_CONFIRMATION, confirmationNumber, receipt);\n        }).on('receipt', (receipt) => {\n          emitter.emit(eeConstants.UNREGISTER_RECEIPT, receipt);\n        });\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Deposit ENG tokens in the worker's bank. Worker must be registered prior to this.\n   *\n   * @param {string} account - Worker's ETH address\n   * @param {number} amount - Number of ENG tokens to deposit, in grains (10**8 multiplier) format\n   * @return {EventEmitter} EventEmitter to be listened to track deposit transaction\n   */\n  deposit(account, amount) {\n    const emitter = new EventEmitter();\n    (async () => {\n      const balance = await this.tokenContract.methods.balanceOf(account).call();\n      if (balance < amount) {\n        const msg = 'Not enough tokens in wallet';\n        emitter.emit('error', {\n          name: 'NotEnoughTokens',\n          message: msg,\n        });\n        return;\n      }\n      await this.tokenContract.methods.approve(this.enigmaContract.options.address, amount).send({from: account});\n      try {\n        const receipt = await this.enigmaContract.methods.deposit(account, amount)\n            .send({from: account})\n            .on('transactionHash', (hash) => {\n              emitter.emit(eeConstants.DEPOSIT_TRANSACTION_HASH, hash);\n            })\n            .on('confirmation', (confirmationNumber, receipt) => {\n              emitter.emit(eeConstants.DEPOSIT_CONFIRMATION, confirmationNumber, receipt);\n            });\n        emitter.emit(eeConstants.DEPOSIT_RECEIPT, receipt);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Withdraw ENG tokens from the worker's bank. Worker must be in the logged out state and cannot withdraw in the\n   * same epoch as logging out.\n   *\n   * @param {string} account - Worker's ETH address\n   * @param {number} amount - Number of ENG tokens to deposit, in grains (10**8 multiplier) format\n   * @return {EventEmitter} EventEmitter to be listened to track deposit transaction\n   */\n  withdraw(account, amount) {\n    const emitter = new EventEmitter();\n    (async () => {\n      try {\n        await this.enigmaContract.methods.withdraw(amount).\n            send({from: account}).\n            on('transactionHash', (hash) => {\n              emitter.emit(eeConstants.WITHDRAW_TRANSACTION_HASH, hash);\n            }).\n            on('confirmation', (confirmationNumber, receipt) => {\n              emitter.emit(eeConstants.WITHDRAW_CONFIRMATION, confirmationNumber, receipt);\n            }).\n            on('receipt', (receipt) => {\n              emitter.emit(eeConstants.WITHDRAW_RECEIPT, receipt);\n            });\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Get token balance for worker\n   *\n   * @param {string} account - Worker's ETH address\n   * @return {Promise} Resolves to ENG token balance in grains (10**8 multiplier) format\n   */\n  async getBalance(account) {\n    return parseInt((await this.enigmaContract.methods.getWorker(account).call()).balance);\n  }\n\n  /**\n   * Get worker's signer address\n   *\n   * @param {string} account - Worker's ETH address\n   * @return {Promise} Resolves to worker's signer address\n   */\n  async getWorkerSignerAddr(account) {\n    return (await this.enigmaContract.methods.getWorker(account).call()).signer;\n  }\n\n  /**\n   * Get worker's operating address from staking address\n   *\n   * @param {string} account - Worker's ETH address\n   * @return {Promise} Resolves to worker's signer address\n   */\n  async getOperatingAddressFromStakingAddress(account) {\n    return await this.enigmaContract.methods.getOperatingAddressFromStakingAddress(account).call();\n  }\n}\n","import utils from '../enigma-utils';\n\n/**\n * Encapsulates the Task\n */\nexport default class Task {\n  /**\n   * Task wrapper for contract deployment and regular tasks. This object is iteratively built up during the task\n   * lifecycle\n   *\n   * @param {string} scAddr\n   * @param {string} encryptedFn\n   * @param {string} encryptedAbiEncodedArgs\n   * @param {Number} gasLimit\n   * @param {Number} gasPx\n   * @param {string} msgId\n   * @param {string} userPubKey\n   * @param {Number} firstBlockNumber\n   * @param {string} workerAddress\n   * @param {string} workerEncryptionKey\n   * @param {string} sender\n   * @param {string} userTaskSig\n   * @param {Number} nonce\n   * @param {string} preCode\n   * @param {string} preCodeHash\n   * @param {boolean} isContractDeploymentTask\n   */\n  constructor(scAddr, encryptedFn, encryptedAbiEncodedArgs, gasLimit, gasPx, msgId, userPubKey, firstBlockNumber,\n      workerAddress, workerEncryptionKey, sender, userTaskSig, nonce, preCode, preCodeHash,\n      isContractDeploymentTask) {\n    // Initial task attributes\n    this.inputsHash = utils.hash([encryptedFn, encryptedAbiEncodedArgs,\n      isContractDeploymentTask ? preCodeHash : scAddr, userPubKey]);\n    this.scAddr = scAddr;\n    this.encryptedFn = encryptedFn;\n    this.encryptedAbiEncodedArgs = encryptedAbiEncodedArgs;\n    this.gasLimit = gasLimit;\n    this.gasPx = gasPx;\n    this.msgId = msgId;\n    this.userPubKey = userPubKey;\n    this.firstBlockNumber = firstBlockNumber;\n    this.workerAddress = workerAddress;\n    this.workerEncryptionKey = workerEncryptionKey;\n    this.sender = sender;\n    this.userTaskSig = userTaskSig;\n    this.nonce = nonce;\n    this.preCode = preCode;\n    this.preCodeHash = preCodeHash;\n    this.isContractDeploymentTask = isContractDeploymentTask;\n\n    // Attributes added to task when task record is created on ETH, most critically, the taskId (a unique value\n    // for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit,\n    // gas price, user's ETH address), user's nonce value monotonically increasing for every task deployment)\n    this.transactionHash = '';\n    this.taskId = '';\n    this.receipt = '';\n    this.ethStatus = 0;\n    this.proof = '';\n    this.creationBlockNumber = -1;\n\n    // Attributes added to task when computation result is being polled/retrieved from the ENG network\n    this.encryptedAbiEncodedOutputs = '';\n    this.delta = '';\n    this.usedGas = '';\n    this.ethereumPayload = '';\n    this.ethereumAddress = '';\n    this.workerTaskSig = '';\n    this.engStatus = 'null';\n\n    this.decryptedOutput = '';\n  }\n}\n","/* eslint-disable prefer-spread,prefer-rest-params,valid-jsdoc */\nimport EnigmaContract from '../../build/contracts/Enigma';\nimport EnigmaTokenContract from '../../build/contracts/EnigmaToken';\nimport Admin from './Admin';\nimport Task from './models/Task';\nimport EventEmitter from 'eventemitter3';\nimport web3Utils from 'web3-utils';\nimport jaysonBrowserClient from 'jayson/lib/client/browser';\nimport axios from 'axios';\nimport utils from './enigma-utils';\nimport forge from 'node-forge';\nimport JSBI from 'jsbi';\nimport retry from 'retry';\nimport * as abi from 'ethereumjs-abi';\nimport EthCrypto from 'eth-crypto';\nimport * as eeConstants from './emitterConstants';\n\n/**\n * Class encapsulation the Enigma operations.\n */\nexport default class Enigma {\n  /**\n   * The Enigma JS library constructor - a wrapper for Ethereum's Web3 library, offering additional services to\n   * leverage the Enigma protocol's unique features.\n   *\n   * @param {Web3} web3 - Web3 provider for the library\n   * @param {string} enigmaContractAddr - Address the Enigma contract is deployed to on Ethereum\n   * @param {string} tokenContractAddr - Address the Enigma token contract is deployed to on Ethereum\n   * @param {string} rpcAddr - Enigma p2p network address for RPC calls\n   * @param {Object} txDefaults\n   */\n  constructor(web3, enigmaContractAddr, tokenContractAddr, rpcAddr, txDefaults = {}, config = {}) {\n    this.web3 = web3;\n    this.txDefaults = txDefaults;\n\n    this.config = {};\n    this.config.retry = {};\n    this.config.retry.retries = config.retry ?\n      (config.retry.retries != null ? config.retry.retries : 5) : 5;\n    this.config.retry.factor = config.retry ?\n      (config.retry.factor != null ? config.retry.factor : 2) : 2;\n    this.config.retry.minTimeout = config.retry ?\n      (config.retry.minTimeout != null ? config.retry.minTimeout : 2000) : 2000;\n    this.config.retry.maxTimeout = config.retry ?\n      (config.retry.maxTimeout != null ? config.retry.maxTimeout : 'Infinity') : 'Infinity';\n    this.config.retry.randomize = config.retry ?\n      (config.retry.randomize != null ? config.retry.randomize : true) : true;\n\n    // axios callback for jayson rpc client to interface with ENG network\n    const callServer = function(request, callback) {\n      const config = {\n        headers: {\n          'Content-Type': 'application/json',\n          'credentials': 'include',\n        },\n      };\n      axios.post(rpcAddr, JSON.parse(request), config).then((response) => {\n        if (eeConstants.ERROR in response.data) {\n          callback(response.data.error, null);\n        } else {\n          const text = JSON.stringify(response.data.result);\n          callback(null, text);\n        }\n      }).catch(function(err) {\n        callback({code: -32000, message: err.message}, null);\n      });\n    };\n    this.client = jaysonBrowserClient(callServer, {});\n    this.workerParamsCache = {};\n    this.selectedWorkerGroupCache = {};\n    this.taskKeyLocalStorage = {};\n    this.createContracts(enigmaContractAddr, tokenContractAddr);\n  }\n\n  /**\n   * Initialize the worker-specific admin features\n   */\n  admin() {\n    this.admin = new Admin(this.web3, this.enigmaContract, this.tokenContract, this.txDefaults, this);\n  }\n\n  /**\n   * Initialize the Enigma and Enigma token contracts\n   *\n   * @param {string} enigmaContractAddr - Address the Enigma contract is deployed to on Ethereum\n   * @param {string} tokenContractAddr - Address the Enigma token contract is deployed to on Ethereum\n   */\n  createContracts(enigmaContractAddr, tokenContractAddr) {\n    this.enigmaContract = new this.web3.eth.Contract(EnigmaContract['abi'],\n        enigmaContractAddr, this.txDefaults);\n    this.tokenContract = new this.web3.eth.Contract(EnigmaTokenContract['abi'],\n        tokenContractAddr, this.txDefaults);\n  }\n\n  /**\n   * Create a base Task - a wrapper for a task (either contract deployments or compute tasks)\n   *\n   * @param {string} fn - Function name\n   * @param {Array} args - Inputs for task in the form of [[arg1, '<type>'], ..., [argn, '<type>']]\n   * @param {Number} gasLimit - ENG gas limit for task computation\n   * @param {Number} gasPx - ENG gas price for task computation\n   * @param {string} sender - ETH address for task sender\n   * @param {string/Buffer} scAddrOrPreCode - Either secret contract address (string) or precode (Buffer), depending\n   * on if user is running a contract deployment or compute task\n   * @param {boolean} isContractDeploymentTask - Is this task a contract deployment task (if not, it's a compute task)\n   * @returns {EventEmitter} EventEmitter to be listened to track creation of task. Emits a Task with base attributes\n   * to be used for remainder of task lifecycle\n   */\n  createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) {\n    const emitter = new EventEmitter();\n    (async () => {\n      // TODO: never larger that 53-bit?\n      const nonce = parseInt(await this.enigmaContract.methods.getUserTaskDeployments(sender).call());\n      const scAddr = isContractDeploymentTask ? utils.generateScAddr(sender, nonce) : scAddrOrPreCode;\n      let preCode;\n      let preCodeGzip;\n      if (isContractDeploymentTask) {\n        if (Buffer.isBuffer(scAddrOrPreCode)) {\n          preCode = scAddrOrPreCode;\n          // gzip the preCode\n          preCodeGzip = await utils.gzip(preCode);\n        } else {\n          throw Error('PreCode expected to be a Buffer, instead got '+typeof scAddrOrPreCode);\n        }\n      } else {\n        preCode = '';\n        preCodeGzip = '';\n      }\n\n      const preCodeHash = isContractDeploymentTask ?\n        this.web3.utils.soliditySha3({t: 'bytes', value: preCode.toString('hex')}) : '';\n      const argsTranspose = (args === undefined || args.length === 0) ? [[], []] :\n        args[0].map((col, i) => args.map((row) => row[i]));\n      const abiEncodedArgs = utils.remove0x(this.web3.eth.abi.encodeParameters(argsTranspose[1], argsTranspose[0]));\n      const abiEncodedArgsArray = [];\n      for (let n = 0; n < abiEncodedArgs.length; n += 2) {\n        abiEncodedArgsArray.push(parseInt(abiEncodedArgs.substr(n, 2), 16));\n      }\n      const blockNumber = await this.web3.eth.getBlockNumber();\n      const workerParams = await this.getWorkerParams(blockNumber);\n      const firstBlockNumber = workerParams.firstBlockNumber;\n      let workerAddress = await this.selectWorkerGroup(scAddr, workerParams, 1)[0]; // TODO: tmp fix 1 worker\n      workerAddress = workerAddress.toLowerCase().slice(-40); // remove leading '0x' if present\n      const {publicKey, privateKey} = this.obtainTaskKeyPair(sender, nonce);\n      try {\n        const getWorkerEncryptionKeyResult = await new Promise((resolve, reject) => {\n          this.client.request('getWorkerEncryptionKey',\n              {workerAddress: workerAddress, userPubKey: publicKey}, (err, response) => {\n                if (err) {\n                  reject(err);\n                  return;\n                }\n                resolve(response);\n              });\n        });\n        const {result, id} = getWorkerEncryptionKeyResult;\n        const {workerEncryptionKey, workerSig} = result;\n\n        // The signature of the workerEncryptionKey is generated\n        // concatenating the following elements in a bytearray:\n        // len('Enigma User Message') + b'Enigma User Message' + len(workerEncryptionKey) + workerEncryptionKey\n        // Because the first 3 elements are constant, they are hardcoded as follows:\n        // len('Enigma User Message') as a uint64 => 19 in hex => 0000000000000013\n        // bytes of 'Enigma User Message' in hex => 456e69676d612055736572204d657373616765\n        // len(workerEncryptionKey) as a unit64 => 64 in hex => 0000000000000040\n        const hexToVerify = '0x0000000000000013456e69676d612055736572204d6573736167650000000000000040' +\n          workerEncryptionKey;\n\n        // the hashing function soliditySha3 expects hex instead of bytes\n        let recAddress = EthCrypto.recover('0x'+workerSig,\n            this.web3.utils.soliditySha3({t: 'bytes', value: hexToVerify}));\n\n        recAddress = recAddress.toLowerCase().slice(-40); // remove leading '0x' if present\n\n        if (workerAddress !== recAddress) {\n          console.error('Worker address', workerAddress, '!= recovered address', recAddress);\n          emitter.emit(eeConstants.ERROR, {\n            name: 'InvalidWorker',\n            message: `Invalid worker encryption key + signature combo ${workerAddress} != ${recAddress}`,\n          });\n        } else {\n          // Generate derived key from worker's encryption key and user's private key\n          const derivedKey = utils.getDerivedKey(workerEncryptionKey, privateKey);\n          // Encrypt function and ABI-encoded args\n          const encryptedFn = utils.encryptMessage(derivedKey, fn);\n          const encryptedAbiEncodedArgs = utils.encryptMessage(derivedKey, Buffer.from(abiEncodedArgsArray));\n          const msg = this.web3.utils.soliditySha3(\n              {t: 'bytes', v: encryptedFn},\n              {t: 'bytes', v: encryptedAbiEncodedArgs},\n          );\n          const userTaskSig = await this.web3.eth.sign(msg, sender);\n          emitter.emit(eeConstants.CREATE_TASK, new Task(scAddr, encryptedFn, encryptedAbiEncodedArgs, gasLimit, gasPx,\n              id, publicKey, firstBlockNumber, workerAddress, workerEncryptionKey, sender, userTaskSig, nonce,\n              preCodeGzip.toString('base64'), preCodeHash, isContractDeploymentTask));\n        }\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee\n   * and computing the immutable taskId (a unique value for each task computed from hash(user's ETH address, user's\n   * nonce value monotonically increasing for every task deployment). Thus, task records have important implications for\n   * task ordering, fee payments, and verification.\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @returns {EventEmitter} EventEmitter to be listened to track creation of task record. Emits a Task with task\n   * record creation attributes to be used for remainder of task lifecycle\n   */\n  createTaskRecord(task) {\n    const emitter = new EventEmitter();\n    (async () => {\n      const balance = await this.tokenContract.methods.balanceOf(task.sender).call();\n      if (balance < (task.gasLimit * task.gasPx)) {\n        emitter.emit(eeConstants.ERROR, {\n          name: 'NotEnoughTokens',\n          message: 'Not enough tokens to pay the fee',\n        });\n        return;\n      }\n      await this.tokenContract.methods.increaseAllowance(this.enigmaContract.options.address,\n          task.gasLimit * task.gasPx).send({\n        from: task.sender,\n      });\n      try {\n        const receipt = task.isContractDeploymentTask ?\n          await this.enigmaContract.methods.createDeploymentTaskRecord(task.inputsHash, task.gasLimit,\n              task.gasPx, task.firstBlockNumber, task.nonce).send({\n            from: task.sender,\n          }).on('transactionHash', (hash) => {\n            task.transactionHash = hash;\n            emitter.emit(eeConstants.CREATE_TASK_RECORD_TRANSACTION_HASH, hash);\n          }).on('confirmation', (confirmationNumber, receipt) => {\n            emitter.emit(eeConstants.CREATE_TASK_RECORD_CONFIRMATION, confirmationNumber, receipt);\n          }) :\n          await this.enigmaContract.methods.createTaskRecord(task.inputsHash, task.gasLimit, task.gasPx,\n              task.firstBlockNumber).send({\n            from: task.sender,\n          }).on('transactionHash', (hash) => {\n            task.transactionHash = hash;\n            emitter.emit(eeConstants.CREATE_TASK_RECORD_TRANSACTION_HASH, hash);\n          }).on('confirmation', (confirmationNumber, receipt) => {\n            emitter.emit(eeConstants.CREATE_TASK_RECORD_CONFIRMATION, confirmationNumber, receipt);\n          });\n        task.taskId = receipt.events.TaskRecordCreated.returnValues.taskId;\n        task.receipt = receipt;\n        task.ethStatus = 1;\n        task.creationBlockNumber = receipt.blockNumber;\n        emitter.emit(eeConstants.CREATE_TASK_RECORD_RECEIPT, receipt);\n        emitter.emit(eeConstants.CREATE_TASK_RECORD, task);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Get the Task's task record status from Ethereum\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {Promise} Resolves to Task wrapper with updated ethStatus and proof properties\n   */\n  async getTaskRecordStatus(task) {\n    const result = await this.enigmaContract.methods.getTaskRecord(task.taskId).call();\n    task.ethStatus = parseInt(result.status);\n    task.proof = result.proof;\n    return task;\n  }\n\n  /**\n   * Get the Task's task record status from Ethereum\n   *\n   * @param {string} taskId - Task ID\n   * @return {Promise} Resolves to TaskRecord struct\n   */\n  async getTaskRecordFromTaskId(taskId) {\n    const taskRecord = await this.enigmaContract.methods.getTaskRecord(taskId).call();\n    return {\n      sender: taskRecord.sender,\n      inputsHash: taskRecord.inputsHash,\n      outputHash: taskRecord.outputHash,\n      gasLimit: parseInt(taskRecord.gasLimit),\n      gasPx: parseInt(taskRecord.gasPx),\n      blockNumber: parseInt(taskRecord.blockNumber),\n      status: parseInt(taskRecord.status),\n      proof: taskRecord.proof,\n    };\n  }\n\n  /**\n   * Fetch output hash for a given task\n   *\n   * @param {Task} task - Task wrapper\n   * @return {Promise} - Resolves to output hash for the task\n   */\n  async getTaskOutputHash(task) {\n    return (await this.enigmaContract.methods.getTaskRecord(task.taskId).call()).outputHash;\n  }\n\n  /**\n   * Find SGX report\n   *\n   * @param {string} custodian - Worker's address\n   * @return {Promise} Resolves to SGX report for the worker\n   */\n  async getReport(custodian) {\n    return await this.enigmaContract.methods.getReport(custodian).call();\n  }\n\n  /**\n   * Given a block number, obtain the worker parameters. These parameters remain the same for a given secret\n   * contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes.\n   *\n   * @param {int} blockNumber - Block number of task record's mining\n   * @return {Promise} Resolves to the worker params, which includes a seed (random int generated from the principal\n   * node), first block number for the epoch, list of active work addresses (ordered list of worker signing addresses\n   * that were logged in at the start of the epoch), and list of active worker balances\n   */\n  async getWorkerParams(blockNumber) {\n    if ((Object.keys(this.workerParamsCache).length === 0) ||\n      (blockNumber - this.workerParamsCache.firstBlockNumber >= this.epochSize)) {\n      this.epochSize = await this.enigmaContract.methods.getEpochSize().call();\n      const getWorkerParamsResult = await this.enigmaContract.methods.getWorkerParams(blockNumber).call();\n      this.workerParamsCache = {\n        firstBlockNumber: parseInt(getWorkerParamsResult[0]),\n        seed: JSBI.BigInt(getWorkerParamsResult[1]),\n        workers: getWorkerParamsResult[2],\n        stakes: getWorkerParamsResult[3].map((x) => JSBI.BigInt(x)),\n      };\n    }\n    return this.workerParamsCache;\n  }\n\n  /**\n   * Select the workers weighted-randomly based on the staked token amount that will run the computation task\n   *\n   * @param {string} scAddr - Secret contract address\n   * @param {Object} params - Worker params (epoch first block number, seed, worker signing addresses, worker stakes)\n   * @param {number} workerGroupSize - Number of workers to be selected for task\n   * @return {Array} An array of selected workers where each selected worker is chosen with probability equal to\n   * number of staked tokens\n   */\n  selectWorkerGroup(scAddr, params, workerGroupSize = 5) {\n    // Find total number of staked tokens for workers\n    const tokenCpt = params.stakes.reduce((a, b) => JSBI.add(a, b), JSBI.BigInt(0));\n    let nonce = 0;\n    const selectedWorkers = [];\n    do {\n      // Unique hash for epoch, secret contract address, and nonce\n      const msg = abi.rawEncode(\n          ['uint256', 'bytes32', 'uint256'],\n          [params.seed.toString(10), scAddr, nonce],\n      );\n      const hash = web3Utils.keccak256(msg);\n      // Find random number between [0, tokenCpt)\n      let randVal = JSBI.remainder(JSBI.BigInt(hash), tokenCpt);\n      let selectedWorker = params.workers[params.workers.length - 1];\n      // Loop through each worker, subtracting worker's balance from the random number computed above. Once the\n      // decrementing randVal becomes negative, add the worker whose balance caused this to the list of selected\n      // workers. If worker has already been selected, increase nonce by one, resulting in a new hash computed above.\n      for (let i = 0; i < params.workers.length; i++) {\n        randVal = JSBI.subtract(randVal, params.stakes[i]);\n        if (randVal <= 0) {\n          selectedWorker = params.workers[i];\n          break;\n        }\n      }\n      if (!selectedWorkers.includes(selectedWorker)) {\n        selectedWorkers.push(selectedWorker);\n      }\n      nonce++;\n    }\n    while (selectedWorkers.length < workerGroupSize);\n    return selectedWorkers;\n  }\n\n  /**\n   * Send Task to Enigma p2p network for computation\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {EventEmitter} EventEmitter to be listened to track submission of Task to Enigma p2p network. Emits\n   * a response from the ENG network indicating whether client is ready to track the remainder of the task lifecycle\n   */\n  sendTaskInput(task) {\n    const emitter = new EventEmitter();\n    (async () => {\n      let rpcEndpointName = eeConstants.RPC_SEND_TASK_INPUT;\n      let emitName = eeConstants.SEND_TASK_INPUT_RESULT;\n      if (task.isContractDeploymentTask) {\n        rpcEndpointName = eeConstants.RPC_DEPLOY_SECRET_CONTRACT;\n        emitName = eeConstants.DEPLOY_SECRET_CONTRACT_RESULT;\n      }\n      try {\n        await new Promise((resolve, reject) => {\n          this.client.request(rpcEndpointName, Enigma.serializeTask(task), (err, response) => {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(response);\n          });\n        });\n        emitter.emit(emitName, task);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Get task result from p2p network\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {EventEmitter} EventEmitter to be listened to track getting result from Enigma network. Emits\n   * a response from the ENG network.\n   */\n  getTaskResult(task) {\n    const emitter = new EventEmitter();\n\n    const operation = retry.operation(this.config.retry);\n    operation.attempt(async (currentAttempt)=>{\n      try {\n        const getTaskResultResult = await new Promise((resolve, reject) => {\n          this.client.request(eeConstants.RPC_GET_TASK_RESULT,\n              {taskId: utils.remove0x(task.taskId)}, (err, response) => {\n                if (err) {\n                  reject(err);\n                  return;\n                }\n                resolve(response);\n              });\n        });\n        if (getTaskResultResult.result) {\n          switch (getTaskResultResult.result.status) {\n            case eeConstants.GET_TASK_RESULT_SUCCESS:\n              task.delta = getTaskResultResult.result.delta;\n              task.ethereumPayload = getTaskResultResult.result.ethereumPayload;\n              task.ethereumAddress = getTaskResultResult.result.ethereumAddress;\n              task.preCodeHash = getTaskResultResult.result.preCodeHash;\n            case eeConstants.GET_TASK_RESULT_FAILED:\n              task.encryptedAbiEncodedOutputs = getTaskResultResult.result.output;\n              task.usedGas = getTaskResultResult.result.usedGas;\n              task.workerTaskSig = getTaskResultResult.result.signature;\n            case eeConstants.GET_TASK_RESULT_UNVERIFIED:\n            case eeConstants.GET_TASK_RESULT_INPROGRESS:\n              task.engStatus = getTaskResultResult.result.status;\n              break;\n            default:\n              throw (new Error('Invalid task result status')).message;\n          }\n        } else {\n          if (operation.retry(true)) {\n            console.log('Warning: Got an empty TaskResult on attempt '+\n              currentAttempt+' of '+(this.config.retry.retries + 1)+'. Retrying...');\n            return;\n          } else {\n            task.engStatus = null;\n          }\n        }\n        emitter.emit(eeConstants.GET_TASK_RESULT_RESULT, task);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err);\n      }\n    });\n\n    return emitter;\n  }\n\n  /**\n   * Return fees for task\n   *\n   * @param {Task} task - Task wrapper\n   * @returns {EventEmitter} EventEmitter to be listened to track return of fees\n   */\n  returnFeesForTask(task) {\n    const emitter = new EventEmitter();\n    (async () => {\n      const taskTimeoutSize = await this.enigmaContract.methods.getTaskTimeoutSize().call();\n      const blockNumber = await this.web3.eth.getBlockNumber();\n      if (blockNumber - task.creationBlockNumber <= taskTimeoutSize) {\n        emitter.emit(eeConstants.ERROR, {\n          name: 'InvalidTaskReturn',\n          message: 'Not enough time has elapsed to return task funds',\n        });\n        return;\n      }\n      try {\n        const receipt = await this.enigmaContract.methods.returnFeesForTask(task.taskId).send({\n          from: task.sender,\n        });\n        task.ethStatus = eeConstants.ETH_STATUS_FAILED_RETURN;\n        emitter.emit(eeConstants.RETURN_FEES_FOR_TASK_RECEIPT, receipt);\n        emitter.emit(eeConstants.RETURN_FEES_FOR_TASK, task);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Decrypt task result\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {Task} Task result wrapper with an updated decrypted output attribute\n   */\n  async decryptTaskResult(task) {\n    console.log('task.encryptedAbiEncodedOutputs is '+task.encryptedAbiEncodedOutputs);\n    if (task.encryptedAbiEncodedOutputs) {\n      const {privateKey} = this.obtainTaskKeyPair(task.sender, task.nonce);\n      const derivedKey = utils.getDerivedKey(task.workerEncryptionKey, privateKey);\n      task.decryptedOutput = utils.decryptMessage(derivedKey, task.encryptedAbiEncodedOutputs);\n    } else {\n      console.log('Warning: task.encryptedAbiEncodedOutputs is empty, there is nothing to decrypt.');\n      task.decryptedOutput = null;\n    }\n    return task;\n  }\n\n  /**\n   * Verify ENG network output matches output registered on ETH\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {boolean} True/false on whether outputs match\n   */\n  async verifyTaskOutput(task) {\n    const ethOutputHash = await this.getTaskOutputHash(task);\n    const engOutputHash = this.web3.utils.soliditySha3(\n        {t: 'bytes', value: task.encryptedAbiEncodedOutputs.toString('hex')}\n    );\n    return ethOutputHash === engOutputHash;\n  }\n\n  /**\n   * Verify ENG network status matches status registered on ETH\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {boolean} True/false on whether statuses match\n   */\n  async verifyTaskStatus(task) {\n    const ethStatus = (await this.getTaskRecordStatus(task)).ethStatus;\n    switch (task.engStatus) {\n      case eeConstants.GET_TASK_RESULT_SUCCESS:\n        return ethStatus === eeConstants.ETH_STATUS_VERIFIED;\n        break;\n      case eeConstants.GET_TASK_RESULT_FAILED:\n        return ethStatus === eeConstants.ETH_STATUS_FAILED;\n        break;\n      case eeConstants.GET_TASK_RESULT_UNVERIFIED:\n      case eeConstants.GET_TASK_RESULT_INPROGRESS:\n        return ethStatus === eeConstants.ETH_STATUS_CREATED;\n        break;\n      default:\n        return ethStatus === eeConstants.ETH_STATUS_UNDEFINED;\n    }\n  }\n\n  /**\n   * Generator function for polling the Enigma p2p network for task status\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @param {boolean} withResult - Task wrapper for contract deployment and compute tasks\n   */\n  * pollTaskStatusGen(task, withResult) {\n    while (true) {\n      yield new Promise((resolve, reject) => {\n        this.client.request(eeConstants.RPC_GET_TASK_STATUS, {\n          taskId: utils.remove0x(task.taskId), workerAddress: task.workerAddress,\n          withResult: withResult,\n        }, (err, response) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          task.engStatus = response.result.status;\n          if (withResult) {\n            task.encryptedAbiEncodedOutputs = response.result.output;\n          }\n          resolve(task);\n        });\n      });\n    }\n  }\n\n  /**\n   * Inner poll status function that continues to poll the Enigma p2p network until the task has been verified\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @param {pollTaskStatusGen} generator - Generator function for polling Enigma p2p network for task status\n   * @param {EventEmitter} emitter - EventEmitter to track Enigma p2p network polling for Task status\n   */\n  innerPollTaskStatus(task, generator, emitter) {\n    const p = generator.next();\n    p.value.then((d) => {\n      emitter.emit(eeConstants.POLL_TASK_STATUS_RESULT, d);\n      if (d.engStatus !== 'SUCCESS' && d.engStatus !== 'FAILED') {\n        this.innerPollTaskStatus(task, generator, emitter);\n      }\n    }).catch((err) => {\n      emitter.emit(eeConstants.ERROR, err);\n    });\n  }\n\n  /**\n   * Poll the Enigma p2p network for a TaskInput's status\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @param {boolean} withResult - Task wrapper for contract deployment and compute tasks\n   * @return {EventEmitter} EventEmitter to be listened to track polling the Enigma p2p network for a Task status.\n   * Emits a Task with task result attributes\n   */\n  pollTaskStatus(task, withResult = false) {\n    const emitter = new EventEmitter();\n    const generator = this.pollTaskStatusGen(task, withResult);\n    this.innerPollTaskStatus(task, generator, emitter);\n    return emitter;\n  }\n\n  /**\n   * Poll the ETH for a Task's status\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @param {Number} interval - Polling interval in ms\n   * @return {Task} Task wrapper with updated ETH status.\n   */\n  async pollTaskETH(task, interval=1000) {\n    while (task.ethStatus === eeConstants.ETH_STATUS_CREATED) {\n      task = await this.getTaskRecordStatus(task);\n      await utils.sleep(interval);\n    }\n    return task;\n  }\n\n  /**\n   * Serialize Task for submission to the Enigma p2p network depending on whether it is a deployment or compute task\n   *\n   * @param {Task} task - Task wrapper for contract deployment or compute task\n   * @return {Object} Serialized Task for submission to the Enigma p2p network\n   */\n  static serializeTask(task) {\n    return task.isContractDeploymentTask ? {\n      preCode: task.preCode,\n      encryptedArgs: utils.remove0x(task.encryptedAbiEncodedArgs), encryptedFn: utils.remove0x(task.encryptedFn),\n      userDHKey: utils.remove0x(task.userPubKey), contractAddress: utils.remove0x(task.scAddr),\n      workerAddress: task.workerAddress,\n    } : {\n      taskId: utils.remove0x(task.taskId), workerAddress: task.workerAddress,\n      encryptedFn: utils.remove0x(task.encryptedFn), encryptedArgs: utils.remove0x(task.encryptedAbiEncodedArgs),\n      contractAddress: utils.remove0x(task.scAddr), userDHKey: utils.remove0x(task.userPubKey),\n    };\n  }\n\n  /**\n   * Obtain task key pair that has been set\n   *\n   * @return {Object} Public key-private key pair\n   */\n  obtainTaskKeyPair(sender, nonce) {\n    // TODO: Developer tool to allow users to select their own unique passphrase to generate private key\n    const taskId = this.getTaskId(sender, nonce);\n\n    const isBrowser = typeof window !== 'undefined';\n    let privateKey;\n    const seed = isBrowser ? atob(window.localStorage.getItem('seed')) :\n      this.taskKeyLocalStorage['seed'];\n\n    if (seed == null) {\n      throw Error('Need to set seed through setTaskKeyPair first');\n    } else {\n      const seedTask = seed + taskId;\n      const random = forge.random.createInstance();\n      random.seedFileSync = function(needed) {\n        return forge.util.fillString(seedTask, needed);\n      };\n      privateKey = forge.util.bytesToHex(random.getBytes(32));\n    }\n\n    const publicKey = EthCrypto.publicKeyByPrivateKey(privateKey);\n\n    isBrowser ? window.localStorage.setItem('encodedPrivateKey'+taskId, btoa(privateKey)) :\n      this.taskKeyLocalStorage['encodedPrivateKey'+taskId] = Buffer.from(privateKey, 'binary').toString('base64');\n\n    return {publicKey, privateKey};\n  }\n\n  /**\n   * Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected\n   * worker. This pair will be stored in local storage for quick retrieval.\n   *\n   * @param {string} seed - Optional seed\n   * @return {string} Seed\n   */\n  setTaskKeyPair(seed='') {\n    const isBrowser = typeof window !== 'undefined';\n    if (seed === '') {\n      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n      for (let i = 0; i < 9; i++) {\n        seed += characters.charAt(Math.floor(Math.random() * characters.length));\n      }\n    }\n    // TODO: Query user for passphrase\n\n    // const random = forge.random.createInstance();\n    // random.seedFileSync = function(needed) {\n    //   return forge.util.fillString(seed, needed);\n    // };\n    // const privateKey = forge.util.bytesToHex(random.getBytes(32));\n    // isBrowser ? window.localStorage.setItem('encodedPrivateKey', btoa(privateKey)) :\n    //   this.taskKeyLocalStorage['encodedPrivateKey'] = Buffer.from(privateKey, 'binary').toString('base64');\n    isBrowser ? window.localStorage.setItem('seed', btoa(seed)) :\n      this.taskKeyLocalStorage['seed'] = seed;\n    return seed;\n  }\n\n  /**\n   * Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the\n   * Enigma network. This is the most efficient and likely most common method for creating and deploying a secret\n   * contract.\n   *\n   * @param {string} fn - Function name\n   * @param {Array} args - Inputs for task in the form of [[arg1, '<type>'], ..., [argn, '<type>']]\n   * @param {Number} gasLimit - ENG gas limit for task computation\n   * @param {Number} gasPx - ENG gas price for task computation\n   * @param {string} sender - ETH address for task sender\n   * @param {string} preCode - Precode for contract deployment\n   * @param {Number} maxRetries - Max number of retries if submitted around epoch change\n   * @return {Task} Task with attributes necessary for task record and Enigma network\n   */\n  deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode, maxRetries=1) {\n    const emitter = new EventEmitter();\n    (async () => {\n      let retryCount = 0;\n      while (true) {\n        try {\n          let scTask = await new Promise((resolve, reject) => {\n            this.createTask(fn, args, gasLimit, gasPx, sender, preCode, true).\n                on(eeConstants.CREATE_TASK, (result) => resolve(result)).\n                on(eeConstants.ERROR, (error) => reject(error));\n          });\n          emitter.emit(eeConstants.CREATE_TASK, scTask);\n          scTask = await new Promise((resolve, reject) => {\n            this.createTaskRecord(scTask).\n                on(eeConstants.CREATE_TASK_RECORD, (result) => resolve(result)).\n                on(eeConstants.ERROR, (error) => reject(error));\n          });\n          emitter.emit(eeConstants.CREATE_TASK_RECORD, scTask);\n          await new Promise((resolve, reject) => {\n            this.sendTaskInput(scTask).\n                on(eeConstants.DEPLOY_SECRET_CONTRACT_RESULT, (receipt) => resolve(receipt)).\n                on(eeConstants.ERROR, (error) => reject(error));\n          });\n          emitter.emit(eeConstants.DEPLOY_SECRET_CONTRACT_RESULT, scTask);\n          break;\n        } catch (err) {\n          if ((retryCount++ >= maxRetries) ||\n            ((err !== 'Returned error: VM Exception while processing transaction: revert Wrong epoch for this task') &&\n            (err !== 'Returned error: VM Exception while processing transaction:'+\n              ' revert Incorrect nonce yielding bad secret contract address'))) {\n            emitter.emit(eeConstants.ERROR, err);\n            break;\n          }\n        }\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Create a compute task - creates base task, creates task record, and sends task to the Enigma network. This is the\n   * most efficient and likely most common method for creating and sending a compute task.\n   *\n   * @param {string} fn - Function name\n   * @param {Array} args - Inputs for task in the form of [[arg1, '<type>'], ..., [argn, '<type>']]\n   * @param {Number} gasLimit - ENG gas limit for task computation\n   * @param {Number} gasPx - ENG gas price for task computation\n   * @param {string} sender - ETH address for task sender\n   * @param {string} scAddr - Secret contract address\n   * @param {Number} maxRetries - Max number of retries if submitted around epoch change\n   * @return {Task} Task with attributes necessary for task record and Enigma network\n   */\n  computeTask(fn, args, gasLimit, gasPx, sender, scAddr, maxRetries=1) {\n    const emitter = new EventEmitter();\n    (async () => {\n      let retryCount = 0;\n      while (true) {\n        try {\n          let task = await new Promise((resolve, reject) => {\n            this.createTask(fn, args, gasLimit, gasPx, sender, scAddr, false).\n                on(eeConstants.CREATE_TASK, (result) => resolve(result)).\n                on(eeConstants.ERROR, (error) => reject(error));\n          });\n          emitter.emit(eeConstants.CREATE_TASK, task);\n          task = await new Promise((resolve, reject) => {\n            this.createTaskRecord(task).\n                on(eeConstants.CREATE_TASK_RECORD, (result) => resolve(result)).\n                on(eeConstants.ERROR, (error) => reject(error));\n          });\n          emitter.emit(eeConstants.CREATE_TASK_RECORD, task);\n          await new Promise((resolve, reject) => {\n            this.sendTaskInput(task).\n                on(eeConstants.SEND_TASK_INPUT_RESULT, (receipt) => resolve(receipt)).\n                on(eeConstants.ERROR, (error) => reject(error));\n          });\n          emitter.emit(eeConstants.SEND_TASK_INPUT_RESULT, task);\n          break;\n        } catch (err) {\n          if ((retryCount++ >= maxRetries) ||\n            (err !== 'Returned error: VM Exception while processing transaction: revert Wrong epoch for this task')) {\n            emitter.emit(eeConstants.ERROR, err);\n            break;\n          }\n        }\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Return the taskId given a sender and a nonce, using the same algorithm used in the contract\n   *\n   * @param {string} sender - Ethereum address\n   * @param {Number} nonce\n   * @return {string} taskId\n   */\n  getTaskId(sender, nonce) {\n    return this.web3.utils.soliditySha3({t: 'address', v: sender}, {t: 'uint256', v: nonce});\n  }\n\n  /**\n   * Return the version number of the library\n   *\n   * @return {string}\n   */\n  static version() {\n    return '0.0.1';\n  }\n}\n","import 'core-js/stable';\nimport 'regenerator-runtime/runtime';\n// window.Promise = Promise;\nimport utils from './enigma-utils';\nimport Enigma from './Enigma';\nimport * as eeConstants from './emitterConstants';\nimport Task from './models/Task';\n\nexport {Enigma, utils, eeConstants, Task};\n"],"sourceRoot":""}