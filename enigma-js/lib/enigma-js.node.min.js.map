{"version":3,"sources":["webpack://enigma-js/webpack/universalModuleDefinition","webpack://enigma-js/webpack/bootstrap","webpack://enigma-js/external \"node-forge\"","webpack://enigma-js/external \"eventemitter3\"","webpack://enigma-js/external \"jsbi\"","webpack://enigma-js/external \"web3-utils\"","webpack://enigma-js/external \"buffer\"","webpack://enigma-js/external \"eth-crypto\"","webpack://enigma-js/external \"elliptic\"","webpack://enigma-js/external \"jayson/lib/client/browser\"","webpack://enigma-js/external \"axios\"","webpack://enigma-js/external \"ethereumjs-abi\"","webpack://enigma-js/external \"@babel/polyfill\"","webpack://enigma-js/./src/enigma-utils.js","webpack://enigma-js/./src/emitterConstants.js","webpack://enigma-js/./src/Admin.js","webpack://enigma-js/./src/models/Task.js","webpack://enigma-js/./src/Enigma.js","webpack://enigma-js/./src/index.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","forge","options","usePureJavaScript","EC","elliptic","ec","appendMessages","hexStr","inputsArray","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","iterator","next","done","input","remove0x","JSBI","BigInt","length","toString","padStart","err","return","appendArrayMessages","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","array","hexString","substring","utils","sender","nonce","web3Utils","soliditySha3","v","seed","workerAddresses","workerStakes","codeHash","inputsHashes","lastStateDeltaHash","stateDeltaHashes","outputHashes","gasesUsed","optionalEthereumData","optionalEthereumContractAddress","successFlag","enclavePublicKey","clientPrivateKey","clientKey","keyFromPrivate","sharedPoints","keyFromPublic","getPublic","mul","getPrivate","y","getY","isOdd","x","getX","yBuffer","Buffer","from","xBuffer","toArrayLike","sha256","md","update","digest","toHex","keyHex","msg","iv","arguments","random","getBytesSync","util","hexToBytes","cipher","createCipher","start","createBuffer","finish","output","putBuffer","tag","putBytes","msgHex","msgBuf","slice","decipher","createDecipher","Error","engValue","Math","pow","hexToAscii","replace","stack","code","parseInt","substr","isNaN","push","String","fromCharCode","join","sleep","ms","Promise","resolve","setTimeout","ERROR","DEPOSIT_TRANSACTION_HASH","DEPOSIT_CONFIRMATION","DEPOSIT_RECEIPT","WITHDRAW_TRANSACTION_HASH","WITHDRAW_CONFIRMATION","WITHDRAW_RECEIPT","LOGIN_TRANSACTION_HASH","LOGIN_CONFIRMATION","LOGIN_RECEIPT","LOGOUT_TRANSACTION_HASH","LOGOUT_CONFIRMATION","LOGOUT_RECEIPT","DEPLOY_SC_ADDR_RESULT","DEPLOY_SC_ETH_TRANSACTION_HASH","DEPLOY_SC_ETH_CONFIRMATION","DEPLOY_SC_ETH_RECEIPT","DEPLOY_SC_ENG_RECEIPT","CREATE_TASK","CREATE_TASK_INPUT","CREATE_TASK_RECORD_TRANSACTION_HASH","CREATE_TASK_RECORD_CONFIRMATION","CREATE_TASK_RECORD_RECEIPT","CREATE_TASK_RECORD","CREATE_TASK_RECORDS_TRANSACTION_HASH","CREATE_TASK_RECORDS_CONFIRMATION","CREATE_TASK_RECORDS_RECEIPT","CREATE_TASK_RECORDS","SEND_TASK_INPUT_RESULT","POLL_TASK_STATUS_RESULT","GET_TASK_RESULT_RESULT","DEPLOY_SECRET_CONTRACT_RESULT","POLL_TASK_ETH_RESULT","Admin","web3","enigmaContract","tokenContract","txDefaults","enigma","_classCallCheck","this","sigAddr","methods","getWorkerFromSigningAddress","result","account","status","report","balance","logs","getWorker","worker","scAddr","getSecretContract","countSecretContracts","stop","getSecretContractAddresses","index","stateDeltaHash","includes","_this","emitter","EventEmitter","_asyncToGenerator","regeneratorRuntime","mark","_callee11","wrap","_context11","prev","login","send","on","hash","emit","eeConstants","confirmationNumber","receipt","t0","message","_this2","_callee12","_context12","logout","amount","_this3","_callee13","_context13","balanceOf","sent","abrupt","approve","address","deposit","_this4","_callee14","_context14","withdraw","signer","Task","encryptedFn","encryptedAbiEncodedArgs","gasLimit","gasPx","msgId","userPubKey","firstBlockNumber","workerAddress","workerEncryptionKey","userTaskSig","preCode","preCodeHash","isContractDeploymentTask","Task_classCallCheck","inputsHash","transactionHash","taskId","ethStatus","proof","creationBlockNumber","encryptedAbiEncodedOutputs","delta","usedGas","ethereumPayload","ethereumAddress","workerTaskSig","engStatus","decryptedOutput","Enigma","enigmaContractAddr","tokenContractAddr","rpcAddr","Enigma_classCallCheck","client","jaysonBrowserClient","request","callback","axios","post","JSON","parse","headers","Content-Type","credentials","then","response","data","error","text","stringify","catch","workerParamsCache","selectedWorkerGroupCache","taskKeyLocalStorage","createContracts","admin","eth","Contract","EnigmaContract","EnigmaTokenContract","fn","args","scAddrOrPreCode","Enigma_asyncToGenerator","_callee","preCodeArray","argsTranspose","abiEncodedArgs","abiEncodedArgsArray","_n","blockNumber","workerParams","_this$obtainTaskKeyPa","publicKey","privateKey","getWorkerEncryptionKeyResult","id","workerSig","hexToVerify","recAddress","derivedKey","_context","getUserTaskDeployments","t1","generateScAddr","map","col","row","abi","encodeParameters","getBlockNumber","getWorkerParams","selectWorkerGroup","toLowerCase","obtainTaskKeyPair","reject","EthCrypto","recover","console","concat","getDerivedKey","encryptMessage","sign","t2","task","_callee2","_context2","createDeploymentTaskRecord","createTaskRecord","events","TaskRecordCreated","returnValues","tasks","_callee3","gasLimits","gasPxs","fees","totalFees","_context3","reduce","a","b","createTaskRecords","taskIds","TaskRecordsCreated","getTaskRecord","outputHash","custodian","getReport","keys","epochSize","getEpochSize","getWorkerParamsResult","workers","stakes","params","workerGroupSize","tokenCpt","add","selectedWorkers","keccak256","randVal","remainder","selectedWorker","subtract","_callee8","rpcEndpointName","emitName","_context8","serializeTask","_this5","_callee9","getTaskResultResult","_context9","signature","decryptMessage","withResult","_this6","generator","_this7","innerPollTaskStatus","pollTaskStatusGen","getTaskRecordStatus","isBrowser","window","encodedPrivateKey","localStorage","getItem","createInstance","seedFileSync","needed","fillString","bytesToHex","getBytes","setItem","btoa","atob","publicKeyByPrivateKey","_this8","scTask","createTask","sendTaskInput","_this9","encryptedArgs","userDHKey","contractAddress","__webpack_exports__","Enigma_Enigma","enigma_utils","emitterConstants_namespaceObject"],"mappings":"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","file":"enigma-js.node.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"enigma-js\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"enigma-js\"] = factory();\n\telse\n\t\troot[\"enigma-js\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n","module.exports = require(\"node-forge\");","module.exports = require(\"eventemitter3\");","module.exports = require(\"jsbi\");","module.exports = require(\"web3-utils\");","module.exports = require(\"buffer\");","module.exports = require(\"eth-crypto\");","module.exports = require(\"elliptic\");","module.exports = require(\"jayson/lib/client/browser\");","module.exports = require(\"axios\");","module.exports = require(\"ethereumjs-abi\");","module.exports = require(\"@babel/polyfill\");","import JSBI from 'jsbi';\nimport web3Utils from 'web3-utils';\n// import RLP from 'rlp';\nimport forge from 'node-forge';\nimport elliptic from 'elliptic';\nimport {Buffer} from 'buffer';\n\nforge.options.usePureJavaScript = true;\n\nconst EC = elliptic.ec;\n\n// const pki = forge.pki;\n\n// const INTEL_CA = '-----BEGIN CERTIFICATE-----\\n' +\n//   'MIIFSzCCA7OgAwIBAgIJANEHdl0yo7CUMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNV\\n' +\n//   'BAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwLU2FudGEgQ2xhcmExGjAYBgNV\\n' +\n//   'BAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQDDCdJbnRlbCBTR1ggQXR0ZXN0\\n' +\n//   'YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwIBcNMTYxMTE0MTUzNzMxWhgPMjA0OTEy\\n' +\n//   'MzEyMzU5NTlaMH4xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwL\\n' +\n//   'U2FudGEgQ2xhcmExGjAYBgNVBAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQD\\n' +\n//   'DCdJbnRlbCBTR1ggQXR0ZXN0YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwggGiMA0G\\n' +\n//   'CSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQCfPGR+tXc8u1EtJzLA10Feu1Wg+p7e\\n' +\n//   'LmSRmeaCHbkQ1TF3Nwl3RmpqXkeGzNLd69QUnWovYyVSndEMyYc3sHecGgfinEeh\\n' +\n//   'rgBJSEdsSJ9FpaFdesjsxqzGRa20PYdnnfWcCTvFoulpbFR4VBuXnnVLVzkUvlXT\\n' +\n//   'L/TAnd8nIZk0zZkFJ7P5LtePvykkar7LcSQO85wtcQe0R1Raf/sQ6wYKaKmFgCGe\\n' +\n//   'NpEJUmg4ktal4qgIAxk+QHUxQE42sxViN5mqglB0QJdUot/o9a/V/mMeH8KvOAiQ\\n' +\n//   'byinkNndn+Bgk5sSV5DFgF0DffVqmVMblt5p3jPtImzBIH0QQrXJq39AT8cRwP5H\\n' +\n//   'afuVeLHcDsRp6hol4P+ZFIhu8mmbI1u0hH3W/0C2BuYXB5PC+5izFFh/nP0lc2Lf\\n' +\n//   '6rELO9LZdnOhpL1ExFOq9H/B8tPQ84T3Sgb4nAifDabNt/zu6MmCGo5U8lwEFtGM\\n' +\n//   'RoOaX4AS+909x00lYnmtwsDVWv9vBiJCXRsCAwEAAaOByTCBxjBgBgNVHR8EWTBX\\n' +\n//   'MFWgU6BRhk9odHRwOi8vdHJ1c3RlZHNlcnZpY2VzLmludGVsLmNvbS9jb250ZW50\\n' +\n//   'L0NSTC9TR1gvQXR0ZXN0YXRpb25SZXBvcnRTaWduaW5nQ0EuY3JsMB0GA1UdDgQW\\n' +\n//   'BBR4Q3t2pn680K9+QjfrNXw7hwFRPDAfBgNVHSMEGDAWgBR4Q3t2pn680K9+Qjfr\\n' +\n//   'NXw7hwFRPDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADANBgkq\\n' +\n//   'hkiG9w0BAQsFAAOCAYEAeF8tYMXICvQqeXYQITkV2oLJsp6J4JAqJabHWxYJHGir\\n' +\n//   'IEqucRiJSSx+HjIJEUVaj8E0QjEud6Y5lNmXlcjqRXaCPOqK0eGRz6hi+ripMtPZ\\n' +\n//   'sFNaBwLQVV905SDjAzDzNIDnrcnXyB4gcDFCvwDFKKgLRjOB/WAqgscDUoGq5ZVi\\n' +\n//   'zLUzTqiQPmULAQaB9c6Oti6snEFJiCQ67JLyW/E83/frzCmO5Ru6WjU4tmsmy8Ra\\n' +\n//   'Ud4APK0wZTGtfPXU7w+IBdG5Ez0kE1qzxGQaL4gINJ1zMyleDnbuS8UicjJijvqA\\n' +\n//   '152Sq049ESDz+1rRGc2NVEqh1KaGXmtXvqxXcTB+Ljy5Bw2ke0v8iGngFBPqCTVB\\n' +\n//   '3op5KBG3RjbF6RRSzwzuWfL7QErNC8WEy5yDVARzTA5+xmBc388v9Dm21HGfcC8O\\n' +\n//   'DD+gT9sSpssq0ascmvH49MOgjt1yoysLtdCtJW/9FZpoOypaHx0R+mJTLwPXVMrv\\n' +\n//   'DaVzWh5aiEx+idkSGMnX\\n' +\n//   '-----END CERTIFICATE-----';\n\n// /**\n//  * Serialize the pem cert.\n//  *\n//  * @param {string} pem\n//  * @return {*}\n//  */\n// function readCert(pem) {\n//   let cert;\n//\n//   try {\n//     cert = pki.certificateFromPem(pem);\n//   } catch (e) {\n//     return {\n//       verified: false,\n//       err: 'Failed to load report certificate : ' + e,\n//     };\n//   }\n//   return cert;\n// }\n\n// /**\n//  * Parse the signer's address from the quote\n//  *\n//  * @param {string} reportContent\n//  * @return {string}\n//  */\n// function parseAddress(reportContent) {\n//   const report = JSON.parse(reportContent);\n//   let b = new Buffer(report.isvEnclaveQuoteBody, 'base64');\n//\n//   return b.slice(368, 410).toString();\n// }\n\n// /**\n//  * Verifies that the worker signer address is associated to an authentic SGX report\n//  *\n//  * @param {string} signer\n//  * @param {string} encodedReport\n//  * @return {*}\n//  */\n// function verifyWorker(signer, encodedReport) {\n//   const reportArgs = RLP.decode(encodedReport);\n//   // console.log ('decoding report\\n', reportArgs[0], '\\n', reportArgs[1], '\\n', reportArgs[2]);\n//   const report = reportArgs[0].toString('utf8');\n//\n//   if (report === 'simulation') {\n//     return {\n//       verified: true,\n//       err: 'Running in simulation mode',\n//     };\n//   }\n//\n//   const reportCert = reportArgs[1].toString('utf8');\n//   const reportSig = reportArgs[2];\n//   const cert = readCert(reportCert);\n//   let md = forge.md.sha256.create();\n//\n//   md.update(report, 'utf8');\n//\n//   try {\n//     // verify data with a public key\n//     // (defaults to RSASSA PKCS#1 v1.5)\n//     // TODO: verify that the public key belongs to the signer\n//     const verified = cert.publicKey.verify(md.digest().bytes(), reportSig);\n//\n//     if (!verified) {\n//       return {\n//         verified: false,\n//         err: 'The signature does not match the signed report',\n//       };\n//     }\n//   } catch (e) {\n//     return {\n//       verified: false,\n//       err: 'Failed to verify the report signature: ' + e,\n//     };\n//   }\n//\n//   let caStore;\n//\n//   try {\n//     caStore = pki.createCaStore([INTEL_CA]);\n//   } catch (e) {\n//     return {\n//       verified: false,\n//       err: 'Failed to load CA certificate: ' + e,\n//     };\n//   }\n//\n//   try {\n//     pki.verifyCertificateChain(caStore, [cert]);\n//   } catch (e) {\n//     return {\n//       verified: false,\n//       err: 'Failed to verify certificate: ' + e,\n//     };\n//   }\n//\n//   const address = parseAddress(report);\n//\n//   if (address !== signer) {\n//     return {\n//       verified: false,\n//       err: 'Signer address does not match the report: ' + signer + ' != ' +\n//         address,\n//     };\n//   }\n//\n//   return {verified: true, err: undefined};\n// }\n\n// /**\n//  * Encode secret contract function arguments\n//  *\n//  * @param {Object} args\n//  * @return {string}\n//  */\n// function encodeArguments(args) {\n//   return '0x' + RLP.encode(args).toString('hex');\n// }\n\n/**\n * Generate a taskId using a hash of all inputs\n * The Enigma contract uses the same logic to generate a matching taskId\n *\n * @param {string} sender\n * @param {Number} nonce\n * @return {string}\n */\nfunction generateScAddr(sender, nonce) {\n  return web3Utils.soliditySha3(\n    {t: 'bytes', v: sender},\n    {t: 'uint', v: nonce},\n  );\n}\n\n/**\n * Generate a taskId using a hash of all inputs\n * The Enigma contract uses the same logic to generate a matching taskId\n *\n * @param {string} hexStr - Buffer being appended to\n * @param {Array} inputsArray - Array of inputs\n * @return {string} - Final appended hex string\n */\nfunction appendMessages(hexStr, inputsArray) {\n  for (let input of inputsArray) {\n    input = remove0x(input);\n    // since the inputs are in hex string, they are twice as long as their bytes\n    hexStr += JSBI.BigInt(input.length/2).toString(16).padStart(16, '0') + input;\n  }\n  return hexStr;\n}\n\n/**\n * Generate a hash of an array containing an array of inputs\n *\n * @param {string} hexStr - Buffer being appended to\n * @param {Array} inputsArray - Array of array of inputs\n * @return {string} - Final appended hex string\n */\nfunction appendArrayMessages(hexStr, inputsArray) {\n  for (let array of inputsArray) {\n    hexStr += JSBI.BigInt(array.length).toString(16).padStart(16, '0');\n    hexStr = appendMessages(hexStr, array);\n  }\n  return hexStr;\n}\n\n/**\n * Generate a hash of all inputs\n *\n * @param {array} inputsArray - Array of inputs\n * @return {string} Hash of inputs\n */\nfunction hash(inputsArray) {\n  let hexStr = appendMessages('', inputsArray);\n  return web3Utils.soliditySha3({t: 'bytes', v: hexStr});\n}\n\n/**\n * Generate a hash of inputs for setting the worker params from the principal node\n *\n * @param {Number} seed - The random integer generated by the enclave\n * @param {Number} nonce - Nonce value for principal node\n * @param {Array} workerAddresses - Worker signing addresses\n * @param {Array} workerStakes - Worker stake balances\n * @return {string} Hash of inputs\n */\nfunction principalHash(seed, nonce, workerAddresses, workerStakes) {\n  let hexStr = '';\n  hexStr = appendMessages(hexStr, [seed, nonce]);\n  hexStr = appendArrayMessages(hexStr, [workerAddresses, workerStakes]);\n  return web3Utils.soliditySha3({t: 'bytes', v: hexStr});\n}\n\n/**\n * Generate a hash of inputs necessary for commit multiple receipts logic\n *\n * @param {string} codeHash\n * @param {Array} inputsHashes\n * @param {string} lastStateDeltaHash\n * @param {Array} stateDeltaHashes\n * @param {Array} outputHashes\n * @param {Array} gasesUsed\n * @param {string} optionalEthereumData\n * @param {string} optionalEthereumContractAddress\n * @param {string} successFlag\n * @return {string} hash of inputs\n */\nfunction commitReceiptsHash(codeHash, inputsHashes, lastStateDeltaHash, stateDeltaHashes, outputHashes, gasesUsed,\n                            optionalEthereumData, optionalEthereumContractAddress, successFlag) {\n  let hexStr = '';\n  hexStr = appendMessages(hexStr, [codeHash]);\n  hexStr = appendArrayMessages(hexStr, [inputsHashes]);\n  hexStr = appendMessages(hexStr, [lastStateDeltaHash]);\n  hexStr = appendArrayMessages(hexStr, [stateDeltaHashes, outputHashes, gasesUsed]);\n  hexStr = appendMessages(hexStr, [optionalEthereumData, optionalEthereumContractAddress, successFlag]);\n\n  return web3Utils.soliditySha3({t: 'bytes', v: hexStr});\n}\n\n// /**\n//  * RLP encode report parts\n//  *\n//  * @param {string} report\n//  * @param {string} cert\n//  * @param {string} sig\n//  * @return {string}\n//  */\n// function encodeReport(report, cert, sig) {\n//   return '0x' + RLP.encode([report, cert, sig]).toString('hex');\n// }\n\n// /**\n//  * Verifies that the specified method signature matches the specs defined\n//  * by the Ethereum abi: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n//  *\n//  * @param {string} methodSig\n//  * @return {boolean}\n//  */\n// function checkMethodSignature(methodSig) {\n//   const rx = /\\b\\((.*?)\\)/g;\n//   const result = rx.test(methodSig);\n//\n//   return result;\n// }\n\n// /**\n//  * Generate an Ethereum-like address from a public key\n//  *\n//  * @param {string} publicKey\n//  * @return {string}\n//  */\n// function toAddress(publicKey) {\n//   const address = EthCrypto.publicKey.toAddress(publicKey);\n//\n//   return address;\n// }\n\n// /**\n//  * Sign a message with the specified private key\n//  *\n//  * @param {string} privateKey\n//  * @param {string} message\n//  * @return {string}\n//  */\n// function sign(privateKey, message) {\n//   return EthCrypto.sign(\n//     privateKey,\n//     message,\n//   );\n// }\n\n// /**\n//  * Returns the address with which the message was signed\n//  *\n//  * @param {string} signature\n//  * @param {string} message\n//  * @return {string}\n//  */\n// function recover(signature, message) {\n//   return EthCrypto.recover(\n//     signature,\n//     message,\n//   );\n// }\n\n// /**\n//  * Returns the public key associated with the message signature\n//  *\n//  * @param {string} signature\n//  * @param {string} message\n//  * @return {string} Public key\n//  */\n// function recoverPublicKey(signature, message) {\n//   return EthCrypto.recoverPublicKey(\n//     signature,\n//     message,\n//   );\n// }\n\n/**\n * This does ECDH key derivation from 2 EC secp256k1 keys.\n * It does so by multiplying the public points by the private point of the over key.\n * This results in a X and Y. it then replaces the Y with 0x02 if Y is even and 0x03 if it's odd.\n * Then it hashes the new Y together with the X using SHA256.\n * Multiplication: https://github.com/indutny/elliptic/blob/master/lib/elliptic/ec/key.js#L104\n * Replacing Y: https://source.that.world/source/libsecp256k1-rs/browse/master/src/ecdh.rs$25\n *\n * @param {string} enclavePublicKey\n * @param {string} clientPrivateKey\n * @return {string}\n */\nfunction getDerivedKey(enclavePublicKey, clientPrivateKey) {\n  let ec = new EC('secp256k1');\n\n  if (enclavePublicKey.length == 128) {\n    enclavePublicKey = '04' + enclavePublicKey;\n  }\n\n  let clientKey = ec.keyFromPrivate(clientPrivateKey, 'hex');\n  let enclaveKey = ec.keyFromPublic(enclavePublicKey, 'hex');\n\n  let sharedPoints = enclaveKey.getPublic().mul(clientKey.getPrivate());\n  let y = 0x02 | (sharedPoints.getY().isOdd() ? 1 : 0);\n  let x = sharedPoints.getX();\n  let yBuffer = Buffer.from([y]);\n  let xBuffer = x.toArrayLike(Buffer, 'be', 32);\n\n  let sha256 = forge.md.sha256.create();\n\n  sha256.update(yBuffer.toString('binary'));\n  sha256.update(xBuffer.toString('binary'));\n\n  return sha256.digest().toHex();\n}\n\n/**\n * Decrypts the encrypted message:\n * Message format: encrypted_message[*]tag[16]iv[12] (represented as: var_name[len])\n *\n * @param {string} keyHex - Derived key\n * @param {string} msgHex - Encrypted message\n * @return {string} Decrypted message\n */\nfunction decryptMessage(keyHex, msgHex) {\n  let key = forge.util.hexToBytes(keyHex);\n  let msgBuf = Buffer.from(msgHex, 'hex');\n  let iv = forge.util.createBuffer(msgBuf.slice(-12));\n  let tag = forge.util.createBuffer(msgBuf.slice(-28, -12));\n  const decipher = forge.cipher.createDecipher('AES-GCM', key);\n\n  decipher.start({iv: iv, tag: tag});\n  decipher.update(\n    forge.util.createBuffer(msgBuf.slice(0, -28)));\n\n  if (decipher.finish()) {\n    return decipher.output.toHex();\n  }\n  throw new Error('decipher did not finish');\n}\n\n/**\n * Encrypts a message using the provided key.\n * Returns an encrypted message in this format:\n * encrypted_message[*]tag[16]iv[12] (represented as: var_name[len])\n *\n * @param {string} keyHex - Derived key\n * @param {string} msg - Unencrypted message\n * @param {string} iv\n * @return {string} Encrypted message\n */\nfunction encryptMessage(keyHex, msg, iv = forge.random.getBytesSync(12)) {\n  let key = forge.util.hexToBytes(keyHex);\n  const cipher = forge.cipher.createCipher('AES-GCM', key);\n\n  cipher.start({iv: iv});\n  cipher.update(forge.util.createBuffer(msg));\n  cipher.finish();\n\n  let result = cipher.output.putBuffer(cipher.mode.tag).putBytes(iv);\n\n  return result.toHex();\n}\n\n/**\n * Converts ENG value to grains format.\n *\n * @param {int} engValue\n * @return {int} ENG value in grains format\n */\nfunction toGrains(engValue) {\n  return engValue * 10**8;\n}\n\n// /**\n//  * Converts grains format to ENG value.\n//  *\n//  * @param {int} grains\n//  * @return {int}\n//  */\n// function fromGrains(grains) {\n//   return grains / 10**8;\n// }\n\n/**\n * Removes '0x' from a hex string, if present\n *\n * @param {string} hexString\n * @return {string}\n */\nfunction remove0x(hexString) {\n  if (hexString.substring(0, 2) == '0x') {\n    return hexString.substring(2);\n  } else {\n    return hexString;\n  }\n}\n\n/**\n * Converts a hex string to its ASCII representation\n *\n * @param {string} hexString\n * @return {string}\n */\nfunction hexToAscii(hexString) {\n  if (!(typeof hexString === 'number' || typeof hexString == 'string')) {\n    return '';\n  }\n  hexString = hexString.toString().replace(/\\s+/gi, '');\n  const stack = [];\n  for (let n = 0; n < hexString.length; n += 2) {\n    const code = parseInt(hexString.substr(n, 2), 16);\n    if (!isNaN(code) && code !== 0) {\n      stack.push(String.fromCharCode(code));\n    }\n  }\n  return stack.join('');\n}\n\n/**\n * Sleeps\n *\n * @param {int} ms\n * @return {undefined}\n */\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n\nlet utils = {};\n\n// utils.readCert = readCert;\n// utils.encodeReport = encodeReport;\nutils.test = () => 'hello2';\n// utils.encodeArguments = encodeArguments;\nutils.generateScAddr = generateScAddr;\nutils.hash = hash;\nutils.principalHash = principalHash;\nutils.commitReceiptsHash = commitReceiptsHash;\n// utils.verifyWorker = verifyWorker;\n// utils.checkMethodSignature = checkMethodSignature;\n// utils.toAddress = toAddress;\n// utils.sign = sign;\n// utils.recover = recover;\n// utils.recoverPublicKey = recoverPublicKey;\nutils.getDerivedKey = getDerivedKey;\nutils.encryptMessage = encryptMessage;\nutils.decryptMessage = decryptMessage;\nutils.toGrains = toGrains;\n// utils.fromGrains = fromGrains;\nutils.remove0x = remove0x;\nutils.hexToAscii = hexToAscii;\nutils.sleep = sleep;\n\nexport default utils;\n","export const ERROR = 'error';\nexport const DEPOSIT_TRANSACTION_HASH = 'depositTransactionHash';\nexport const DEPOSIT_CONFIRMATION = 'depositConfirmation';\nexport const DEPOSIT_RECEIPT = 'depositReceipt';\nexport const WITHDRAW_TRANSACTION_HASH = 'withdrawTransactionHash';\nexport const WITHDRAW_CONFIRMATION = 'withdrawConfirmation';\nexport const WITHDRAW_RECEIPT = 'withdrawReceipt';\nexport const LOGIN_TRANSACTION_HASH = 'loginTransactionHash';\nexport const LOGIN_CONFIRMATION = 'loginConfirmation';\nexport const LOGIN_RECEIPT = 'loginReceipt';\nexport const LOGOUT_TRANSACTION_HASH = 'logoutTransactionHash';\nexport const LOGOUT_CONFIRMATION = 'logoutConfirmation';\nexport const LOGOUT_RECEIPT = 'logoutReceipt';\n\nexport const DEPLOY_SC_ADDR_RESULT = 'deploySCAddrResult';\nexport const DEPLOY_SC_ETH_TRANSACTION_HASH = 'deploySCEthTransactionHash';\nexport const DEPLOY_SC_ETH_CONFIRMATION = 'deploySCEthConfirmation';\nexport const DEPLOY_SC_ETH_RECEIPT = 'deploySCEthReceipt';\nexport const DEPLOY_SC_ENG_RECEIPT = 'deploySCEngReceipt';\n\nexport const CREATE_TASK = 'createTask';\nexport const CREATE_TASK_INPUT = 'createTaskInput';\nexport const CREATE_TASK_RECORD_TRANSACTION_HASH = 'createTaskRecordTransactionHash';\nexport const CREATE_TASK_RECORD_CONFIRMATION = 'createTaskRecordConfirmation';\nexport const CREATE_TASK_RECORD_RECEIPT = 'createTaskRecordReceipt';\nexport const CREATE_TASK_RECORD = 'createTaskRecord';\nexport const CREATE_TASK_RECORDS_TRANSACTION_HASH = 'createTaskRecordsTransactionHash';\nexport const CREATE_TASK_RECORDS_CONFIRMATION = 'createTaskRecordsConfirmation';\nexport const CREATE_TASK_RECORDS_RECEIPT = 'createTaskRecordsReceipt';\nexport const CREATE_TASK_RECORDS = 'createTaskRecords';\n\nexport const SEND_TASK_INPUT_RESULT = 'sendTaskInputResult';\nexport const POLL_TASK_STATUS_RESULT = 'pollTaskStatusResult';\nexport const GET_TASK_RESULT_RESULT = 'getTaskResultResult';\nexport const DEPLOY_SECRET_CONTRACT_RESULT = 'deploySecretContractResult';\n\nexport const POLL_TASK_ETH_RESULT = 'pollTaskETHResult';\n","import EventEmitter from 'eventemitter3';\nimport * as eeConstants from './emitterConstants';\n\n/**\n * Encapsulates the admin operations\n */\nexport default class Admin {\n  /**\n   * Constructor\n   * @param {Web3} web3 - Web3 provider for the library\n   * @param {Web3.Contract} enigmaContract - Enigma contract deployed to Ethereum\n   * @param {Web3.Contract} tokenContract - Enigma token contract deployed to Ethereum\n   * @param {Object} txDefaults\n   * @param {Enigma} enigma - Enigma wrapper instance\n   */\n  constructor(web3, enigmaContract, tokenContract, txDefaults, enigma) {\n    this.web3 = web3;\n    this.enigmaContract = enigmaContract;\n    this.tokenContract = tokenContract;\n    this.txDefaults = txDefaults;\n    this.enigma = enigma;\n  }\n\n  /**\n   * Find worker by signing address\n   *\n   * @param {string} sigAddr - The signing address\n   * @return {Promise} Resolves to worker's details\n   */\n  async findBySigningAddress(sigAddr) {\n    const result = await this.enigmaContract.methods.getWorkerFromSigningAddress(sigAddr).call();\n    return {\n      account: result[0],\n      status: parseInt(result[1][1]),\n      report: result[1][2],\n      balance: parseInt(result[1][3]),\n      logs: result[1][4],\n    };\n  }\n\n  /**\n   * Get the worker's status\n   *\n   * @param {string} account - Worker's ETH address\n   * @return {Promise} Resolves to status of worker (0=Unregistered, 1=LoggedIn, 2=LoggedOut)\n   */\n  async getWorkerStatus(account) {\n    const worker = await this.enigmaContract.methods.getWorker(account).call();\n    return parseInt(worker.status);\n  }\n\n  /**\n   * Checks if a secret contract is deployed\n   *\n   * @param {string} scAddr - Secret contract address\n   * @return {Promise} Resolves to a boolean value whether the contract has been deployed or not\n   */\n  async isDeployed(scAddr) {\n    return parseInt((await this.enigmaContract.methods.getSecretContract(scAddr).call()).status) === 1;\n  }\n\n  /**\n   * Count the number of deployed secret contracts.\n   *\n   * @return {Promise} - Resolves to number of deployed secret contracts\n   */\n  async countSecretContracts() {\n    return parseInt(await this.enigmaContract.methods.countSecretContracts().call());\n  }\n\n  /**\n   * Get the addresses of deployed secret contracts within a specified range.\n   *\n   * @param {number} start - Start index of secret contract address to retrieve (inclusive)\n   * @param {number} stop - Stop index of secret contract address to retrieve (exclusive)\n   * @return {Promise} - Resolves to the addresses of deployed secret contracts within range\n   */\n  async getSecretContractAddresses(start, stop) {\n    return (await this.enigmaContract.methods.getSecretContractAddresses(start, stop).call());\n  }\n\n  /**\n   * Fetches the secret contract bytecode hash\n   *\n   * @param {string} scAddr - Secret contract address\n   * @return {Promise} - Resolves to the bytecode hash of the deployed secret contract\n   */\n  async getCodeHash(scAddr) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).codeHash;\n  }\n\n  /**\n   * Count the state deltas for the specified secret contract.\n   *\n   * @param {string} scAddr - Secret contract address\n   * @return {Promise} - Resolves to count of state deltas\n   */\n  async countStateDeltas(scAddr) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).stateDeltaHashes.length;\n  }\n\n  /**\n   * Fetch the state delta hash at the specified index position\n   *\n   * @param {string} scAddr - Secret contract address\n   * @param {number} index - Index of state delta hash to retrieve\n   * @return {Promise} - Resolves to state delta hash at the specified position\n   */\n  async getStateDeltaHash(scAddr, index) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).stateDeltaHashes[index];\n  }\n\n  /**\n   * Fetch state delta hashes in the specified range\n   *\n   * @param {string} scAddr - Secret contract address\n   * @param {number} start - Start index of state delta hash to retrieve (inclusive)\n   * @param {number} stop - Stop index of state delta hash to retrieve (exclusive)\n   * @return {Promise} - Resolves to the state delta hashes in the specified range\n   */\n  async getStateDeltaHashes(scAddr, start, stop) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).stateDeltaHashes.slice(start, stop);\n  }\n\n  /**\n   * Check that the specified state delta hash is valid.\n   *\n   * @param {string} scAddr - Secret contract address\n   * @param {string} stateDeltaHash - State delta hash for a given task\n   * @return {Promise} Resolves to boolean value for whether the state delta hash is valid\n   */\n  async isValidDeltaHash(scAddr, stateDeltaHash) {\n    return (await this.enigmaContract.methods.getSecretContract(scAddr).call()).stateDeltaHashes.includes(\n      stateDeltaHash);\n  }\n\n  /**\n   * Login the selected worker\n   *\n   * @param {string} account - ETH address for worker being logged in\n   * @return {EventEmitter} EventEmitter to be listened to track login transaction\n   */\n  login(account) {\n    let emitter = new EventEmitter();\n    (async () => {\n      try {\n        await this.enigmaContract.methods.login().send({from: account}).on('transactionHash', (hash) => {\n          emitter.emit(eeConstants.LOGIN_TRANSACTION_HASH, hash);\n        }).on('confirmation', (confirmationNumber, receipt) => {\n          emitter.emit(eeConstants.LOGIN_CONFIRMATION, confirmationNumber, receipt);\n        }).on('receipt', (receipt) => {\n          emitter.emit(eeConstants.LOGIN_RECEIPT, receipt);\n        });\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Logout the selected worker\n   *\n   * @param {string} account - ETH address for worker being logged out\n   * @return {EventEmitter} EventEmitter to be listened to track logout transaction\n   */\n  logout(account) {\n    let emitter = new EventEmitter();\n    (async () => {\n      try {\n        await this.enigmaContract.methods.logout().send({from: account}).on('transactionHash', (hash) => {\n          emitter.emit(eeConstants.LOGOUT_TRANSACTION_HASH, hash);\n        }).on('confirmation', (confirmationNumber, receipt) => {\n          emitter.emit(eeConstants.LOGOUT_CONFIRMATION, confirmationNumber, receipt);\n        }).on('receipt', (receipt) => {\n          emitter.emit(eeConstants.LOGOUT_RECEIPT, receipt);\n        });\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Deposit ENG tokens in the worker's bank. Worker must be registered prior to this.\n   *\n   * @param {string} account - Worker's ETH address\n   * @param {number} amount - Number of ENG tokens to deposit, in grains (10**8 multiplier) format\n   * @return {EventEmitter} EventEmitter to be listened to track deposit transaction\n   */\n  deposit(account, amount) {\n    let emitter = new EventEmitter();\n    (async () => {\n      const balance = await this.tokenContract.methods.balanceOf(account).call();\n      if (balance < amount) {\n        const msg = 'Not enough tokens in wallet';\n        emitter.emit('error', {\n          name: 'NotEnoughTokens',\n          message: msg,\n        });\n        return;\n      }\n      await this.tokenContract.methods.approve(this.enigmaContract.options.address, amount).send({from: account});\n      try {\n        const receipt = await this.enigmaContract.methods.deposit(account, amount).\n          send({from: account}).\n          on('transactionHash', (hash) => {\n            emitter.emit(eeConstants.DEPOSIT_TRANSACTION_HASH, hash);\n          }).\n          on('confirmation', (confirmationNumber, receipt) => {\n            emitter.emit(eeConstants.DEPOSIT_CONFIRMATION, confirmationNumber, receipt);\n          });\n        emitter.emit(eeConstants.DEPOSIT_RECEIPT, receipt);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Withdraw ENG tokens from the worker's bank. Worker must be in the logged out state and cannot withdraw in the\n   * same epoch as logging out.\n   *\n   * @param {string} account - Worker's ETH address\n   * @param {number} amount - Number of ENG tokens to deposit, in grains (10**8 multiplier) format\n   * @return {EventEmitter} EventEmitter to be listened to track deposit transaction\n   */\n  withdraw(account, amount) {\n    let emitter = new EventEmitter();\n    (async () => {\n      try {\n        await this.enigmaContract.methods.withdraw(amount).\n          send({from: account}).\n          on('transactionHash', (hash) => {\n            emitter.emit(eeConstants.WITHDRAW_TRANSACTION_HASH, hash);\n          }).\n          on('confirmation', (confirmationNumber, receipt) => {\n            emitter.emit(eeConstants.WITHDRAW_CONFIRMATION, confirmationNumber, receipt);\n          }).\n          on('receipt', (receipt) => {\n            emitter.emit(eeConstants.WITHDRAW_RECEIPT, receipt);\n          });\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Get token balance for worker\n   *\n   * @param {string} account - Worker's ETH address\n   * @return {Promise} Resolves to ENG token balance in grains (10**8 multiplier) format\n   */\n  async getBalance(account) {\n    return parseInt((await this.enigmaContract.methods.getWorker(account).call()).balance);\n  }\n\n  /**\n   * Get worker's signer address\n   *\n   * @param {string} account - Worker's ETH address\n   * @return {Promise} Resolves to worker's signer address\n   */\n  async getWorkerSignerAddr(account) {\n    return (await this.enigmaContract.methods.getWorker(account).call()).signer;\n  }\n}\n","import utils from '../enigma-utils';\n\n/**\n * Encapsulates the Task\n */\nexport default class Task {\n  /**\n   * Task wrapper for contract deployment and regular tasks. This object is iteratively built up during the task\n   * lifecycle\n   *\n   * @param {string} scAddr\n   * @param {string} encryptedFn\n   * @param {string} encryptedAbiEncodedArgs\n   * @param {Number} gasLimit\n   * @param {Number} gasPx\n   * @param {string} msgId\n   * @param {string} userPubKey\n   * @param {Number} firstBlockNumber\n   * @param {string} workerAddress\n   * @param {string} workerEncryptionKey\n   * @param {string} sender\n   * @param {string} userTaskSig\n   * @param {Number} nonce\n   * @param {string} preCode\n   * @param {string} preCodeHash\n   * @param {boolean} isContractDeploymentTask\n   */\n  constructor(scAddr, encryptedFn, encryptedAbiEncodedArgs, gasLimit, gasPx, msgId, userPubKey, firstBlockNumber,\n              workerAddress, workerEncryptionKey, sender, userTaskSig, nonce, preCode, preCodeHash,\n              isContractDeploymentTask) {\n    // Initial task attributes\n    this.inputsHash = utils.hash([encryptedFn, encryptedAbiEncodedArgs,\n      isContractDeploymentTask ? preCodeHash : scAddr, userPubKey]);\n    this.scAddr = scAddr;\n    this.encryptedFn = encryptedFn;\n    this.encryptedAbiEncodedArgs = encryptedAbiEncodedArgs;\n    this.gasLimit = gasLimit;\n    this.gasPx = gasPx;\n    this.msgId = msgId;\n    this.userPubKey = userPubKey;\n    this.firstBlockNumber = firstBlockNumber;\n    this.workerAddress = workerAddress;\n    this.workerEncryptionKey = workerEncryptionKey;\n    this.sender = sender;\n    this.userTaskSig = userTaskSig;\n    this.nonce = nonce;\n    this.preCode = preCode;\n    this.preCodeHash = preCodeHash;\n    this.isContractDeploymentTask = isContractDeploymentTask;\n\n    // Attributes added to task when task record is created on ETH, most critically, the taskId (a unique value\n    // for each task computed from hash(hash(encrypted function signature, encrypted ABI-encoded arguments, gas limit,\n    // gas price, user's ETH address), user's nonce value monotonically increasing for every task deployment)\n    this.transactionHash = '';\n    this.taskId = '';\n    this.receipt = '';\n    this.ethStatus = 0;\n    this.proof = '';\n    this.creationBlockNumber = -1;\n\n    // Attributes added to task when computation result is being polled/retrieved from the ENG network\n    this.encryptedAbiEncodedOutputs = '';\n    this.delta = '';\n    this.usedGas = '';\n    this.ethereumPayload = '';\n    this.ethereumAddress = '';\n    this.workerTaskSig = '';\n    this.engStatus = 'null';\n\n    this.decryptedOutput = '';\n  }\n}\n","/* eslint-disable prefer-spread,prefer-rest-params,valid-jsdoc */\nimport EnigmaContract from '../../build/contracts/Enigma';\nimport EnigmaTokenContract from '../../build/contracts/EnigmaToken';\nimport Admin from './Admin';\nimport Task from './models/Task';\nimport EventEmitter from 'eventemitter3';\nimport web3Utils from 'web3-utils';\nimport jaysonBrowserClient from 'jayson/lib/client/browser';\nimport axios from 'axios';\nimport utils from './enigma-utils';\nimport forge from 'node-forge';\nimport JSBI from 'jsbi';\nimport * as abi from 'ethereumjs-abi';\nimport EthCrypto from 'eth-crypto';\nimport * as eeConstants from './emitterConstants';\n\n/**\n * Class encapsulation the Enigma operations.\n */\nexport default class Enigma {\n  /**\n   * The Enigma JS library constructor - a wrapper for Ethereum's Web3 library, offering additional services to\n   * leverage the Enigma protocol's unique features.\n   *\n   * @param {Web3} web3 - Web3 provider for the library\n   * @param {string} enigmaContractAddr - Address the Enigma contract is deployed to on Ethereum\n   * @param {string} tokenContractAddr - Address the Enigma token contract is deployed to on Ethereum\n   * @param {string} rpcAddr - Enigma p2p network address for RPC calls\n   * @param {Object} txDefaults\n   */\n  constructor(web3, enigmaContractAddr, tokenContractAddr, rpcAddr, txDefaults = {}) {\n    this.web3 = web3;\n    this.txDefaults = txDefaults;\n    // axios callback for jayson rpc client to interface with ENG network\n    let callServer = function(request, callback) {\n      let config = {\n        headers: {\n          'Content-Type': 'application/json',\n          'credentials': 'include',\n        },\n      };\n      axios.post(rpcAddr, JSON.parse(request), config).then((response) => {\n        if (eeConstants.ERROR in response.data) {\n          callback(response.data.error, null);\n        } else {\n          let text = JSON.stringify(response.data.result);\n          callback(null, text);\n        }\n      }).catch(function(err) {\n        callback({code: -32000, message: err.message}, null);\n      });\n    };\n    this.client = jaysonBrowserClient(callServer, {});\n    this.workerParamsCache = {};\n    this.selectedWorkerGroupCache = {};\n    this.taskKeyLocalStorage = {};\n    this.createContracts(enigmaContractAddr, tokenContractAddr);\n  }\n\n  /**\n   * Initialize the worker-specific admin features\n   */\n  admin() {\n    this.admin = new Admin(this.web3, this.enigmaContract, this.tokenContract, this.txDefaults, this);\n  }\n\n  /**\n   * Initialize the Enigma and Enigma token contracts\n   *\n   * @param {string} enigmaContractAddr - Address the Enigma contract is deployed to on Ethereum\n   * @param {string} tokenContractAddr - Address the Enigma token contract is deployed to on Ethereum\n   */\n  createContracts(enigmaContractAddr, tokenContractAddr) {\n    this.enigmaContract = new this.web3.eth.Contract(EnigmaContract['abi'],\n      enigmaContractAddr, this.txDefaults);\n    this.tokenContract = new this.web3.eth.Contract(EnigmaTokenContract['abi'],\n      tokenContractAddr, this.txDefaults);\n  }\n\n  /**\n   * Create a base Task - a wrapper for a task (either contract deployments or compute tasks)\n   *\n   * @param {string} fn - Function name\n   * @param {Array} args - Inputs for task in the form of [[arg1, '<type>'], ..., [argn, '<type>']]\n   * @param {Number} gasLimit - ENG gas limit for task computation\n   * @param {Number} gasPx - ENG gas price for task computation\n   * @param {string} sender - ETH address for task sender\n   * @param {string} scAddrOrPreCode - Either secret contract address or precode, depending on if user is running a\n   * contract deployment or compute task\n   * @param {boolean} isContractDeploymentTask - Is this task a contract deployment task (if not, it's a compute task)\n   * @returns {EventEmitter} EventEmitter to be listened to track creation of task. Emits a Task with base attributes\n   * to be used for remainder of task lifecycle\n   */\n  createTask(fn, args, gasLimit, gasPx, sender, scAddrOrPreCode, isContractDeploymentTask) {\n    let emitter = new EventEmitter();\n    (async () => {\n      // TODO: never larger that 53-bit?\n      const nonce = parseInt(await this.enigmaContract.methods.getUserTaskDeployments(sender).call());\n      const scAddr = isContractDeploymentTask ? utils.generateScAddr(sender, nonce) : scAddrOrPreCode;\n      const preCode = isContractDeploymentTask ? scAddrOrPreCode : '';\n\n      let preCodeArray = [];\n      for (let n = 0; n < preCode.length; n += 2) {\n        preCodeArray.push(parseInt(preCode.substr(n, 2), 16));\n      }\n\n      const preCodeHash = isContractDeploymentTask ?\n        this.web3.utils.soliditySha3({t: 'bytes', value: scAddrOrPreCode}) : '';\n      const argsTranspose = (args === undefined || args.length === 0) ? [[], []] :\n        args[0].map((col, i) => args.map((row) => row[i]));\n      const abiEncodedArgs = utils.remove0x(this.web3.eth.abi.encodeParameters(argsTranspose[1], argsTranspose[0]));\n      let abiEncodedArgsArray = [];\n      for (let n = 0; n < abiEncodedArgs.length; n += 2) {\n        abiEncodedArgsArray.push(parseInt(abiEncodedArgs.substr(n, 2), 16));\n      }\n      const blockNumber = await this.web3.eth.getBlockNumber();\n      const workerParams = await this.getWorkerParams(blockNumber);\n      const firstBlockNumber = workerParams.firstBlockNumber;\n      let workerAddress = await this.selectWorkerGroup(scAddr, workerParams, 1)[0]; // TODO: tmp fix 1 worker\n      workerAddress = workerAddress.toLowerCase().slice(-40); // remove leading '0x' if present\n      const {publicKey, privateKey} = this.obtainTaskKeyPair();\n      try {\n        const getWorkerEncryptionKeyResult = await new Promise((resolve, reject) => {\n          this.client.request('getWorkerEncryptionKey',\n            {workerAddress: workerAddress, userPubKey: publicKey}, (err, response) => {\n              if (err) {\n                reject(err);\n                return;\n              }\n              resolve(response);\n            });\n        });\n        const {result, id} = getWorkerEncryptionKeyResult;\n        const {workerEncryptionKey, workerSig} = result;\n\n        // The signature of the workerEncryptionKey is generated\n        // concatenating the following elements in a bytearray:\n        // len('Enigma User Message') + b'Enigma User Message' + len(workerEncryptionKey) + workerEncryptionKey\n        // Because the first 3 elements are constant, they are hardcoded as follows:\n        // len('Enigma User Message') as a uint64 => 19 in hex => 0000000000000013\n        // bytes of 'Enigma User Message' in hex => 456e69676d612055736572204d657373616765\n        // len(workerEncryptionKey) as a unit64 => 64 in hex => 0000000000000040\n        const hexToVerify = '0x0000000000000013456e69676d612055736572204d6573736167650000000000000040' +\n          workerEncryptionKey;\n\n        // the hashing function soliditySha3 expects hex instead of bytes\n        let recAddress = EthCrypto.recover('0x'+workerSig,\n          this.web3.utils.soliditySha3({t: 'bytes', value: hexToVerify}));\n\n        recAddress = recAddress.toLowerCase().slice(-40); // remove leading '0x' if present\n\n        if (workerAddress !== recAddress) {\n          console.error('Worker address', workerAddress, '!= recovered address', recAddress);\n          emitter.emit(eeConstants.ERROR, {\n            name: 'InvalidWorker',\n            message: `Invalid worker encryption key + signature combo ${workerAddress} != ${recAddress}`,\n          });\n        } else {\n          // Generate derived key from worker's encryption key and user's private key\n          const derivedKey = utils.getDerivedKey(workerEncryptionKey, privateKey);\n          // Encrypt function and ABI-encoded args\n          const encryptedFn = utils.encryptMessage(derivedKey, fn);\n          const encryptedAbiEncodedArgs = utils.encryptMessage(derivedKey, Buffer.from(abiEncodedArgsArray));\n          const msg = this.web3.utils.soliditySha3(\n            {t: 'bytes', v: encryptedFn},\n            {t: 'bytes', v: encryptedAbiEncodedArgs},\n          );\n          const userTaskSig = await this.web3.eth.sign(msg, sender);\n          emitter.emit(eeConstants.CREATE_TASK, new Task(scAddr, encryptedFn, encryptedAbiEncodedArgs, gasLimit, gasPx,\n            id, publicKey, firstBlockNumber, workerAddress, workerEncryptionKey, sender, userTaskSig, nonce,\n            preCodeArray, preCodeHash, isContractDeploymentTask));\n        }\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Create and store a task record on chain (ETH). Task records are necessary for collecting the ENG computation fee\n   * and computing the immutable taskId (a unique value for each task computed from hash(user's ETH address, user's\n   * nonce value monotonically increasing for every task deployment). Thus, task records have important implications for\n   * task ordering, fee payments, and verification.\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @returns {EventEmitter} EventEmitter to be listened to track creation of task record. Emits a Task with task\n   * record creation attributes to be used for remainder of task lifecycle\n   */\n  createTaskRecord(task) {\n    let emitter = new EventEmitter();\n    (async () => {\n      const balance = await this.tokenContract.methods.balanceOf(task.sender).call();\n      if (balance < (task.gasLimit * task.gasPx)) {\n        emitter.emit(eeConstants.ERROR, {\n          name: 'NotEnoughTokens',\n          message: 'Not enough tokens to pay the fee',\n        });\n        return;\n      }\n      await this.tokenContract.methods.approve(this.enigmaContract.options.address, task.gasLimit * task.gasPx).send({\n        from: task.sender,\n      });\n      try {\n        const receipt = task.isContractDeploymentTask ?\n          await this.enigmaContract.methods.createDeploymentTaskRecord(task.inputsHash, task.gasLimit,\n            task.gasPx, task.firstBlockNumber, task.nonce).send({\n            from: task.sender,\n          }).on('transactionHash', (hash) => {\n            task.transactionHash = hash;\n            emitter.emit(eeConstants.CREATE_TASK_RECORD_TRANSACTION_HASH, hash);\n          }).on('confirmation', (confirmationNumber, receipt) => {\n            emitter.emit(eeConstants.CREATE_TASK_RECORD_CONFIRMATION, confirmationNumber, receipt);\n          })\n          :\n          await this.enigmaContract.methods.createTaskRecord(task.inputsHash, task.gasLimit, task.gasPx,\n            task.firstBlockNumber).send({\n            from: task.sender,\n          }).on('transactionHash', (hash) => {\n            task.transactionHash = hash;\n            emitter.emit(eeConstants.CREATE_TASK_RECORD_TRANSACTION_HASH, hash);\n          }).on('confirmation', (confirmationNumber, receipt) => {\n            emitter.emit(eeConstants.CREATE_TASK_RECORD_CONFIRMATION, confirmationNumber, receipt);\n          });\n        task.taskId = receipt.events.TaskRecordCreated.returnValues.taskId;\n        task.receipt = receipt;\n        task.ethStatus = 1;\n        task.creationBlockNumber = receipt.blockNumber;\n        emitter.emit(eeConstants.CREATE_TASK_RECORD_RECEIPT, receipt);\n        emitter.emit(eeConstants.CREATE_TASK_RECORD, task);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err.message);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Create and store task records on chain (ETH). Task records are necessary for collecting the ENG computation fee\n   * and computing the immutable taskId (a unique value for each task computed from hash(user's ETH address, user's\n   * nonce value monotonically increasing for every task deployment). Thus, task records have important implications for\n   * task ordering, fee payments, and verification.\n   *\n   * @param {Array} tasks - Task wrappers for contract deployment and compute tasks\n   * @returns {EventEmitter} EventEmitter to be listened to track creation of task records. Emits Tasks with task\n   * record creation attributes to be used for remainder of task lifecycle\n   */\n  createTaskRecords(tasks) {\n    let emitter = new EventEmitter();\n    (async () => {\n      const inputsHashes = tasks.map((task) => task.inputsHash);\n      const gasLimits = tasks.map((task) => task.gasLimit);\n      const gasPxs = tasks.map((task) => task.gasPx);\n      const fees = tasks.map((task) => task.gasLimit * task.gasPx);\n      const balance = await this.tokenContract.methods.balanceOf(tasks[0].sender).call();\n      const totalFees = fees.reduce((a, b) => a + b, 0);\n      if (balance < totalFees) {\n        emitter.emit(eeConstants.ERROR, {\n          name: 'NotEnoughTokens',\n          message: 'Not enough tokens to pay the fee',\n        });\n        return;\n      }\n      await this.tokenContract.methods.approve(this.enigmaContract.options.address, totalFees).send({\n        from: tasks[0].sender,\n      });\n      await this.enigmaContract.methods.createTaskRecords(inputsHashes, gasLimits, gasPxs, tasks[0].firstBlockNumber).\n        send({\n          from: tasks[0].sender,\n        }).\n        on('transactionHash', (hash) => {\n          for (let i = 0; i < tasks.length; i++) {\n            tasks[i].transactionHash = hash;\n          }\n          emitter.emit(eeConstants.CREATE_TASK_RECORDS_TRANSACTION_HASH, hash);\n        }).\n        on('confirmation', (confirmationNumber, receipt) => {\n          emitter.emit(eeConstants.CREATE_TASK_RECORDS_CONFIRMATION, confirmationNumber, receipt);\n        }).\n        then((receipt) => {\n          const taskIds = receipt.events.TaskRecordsCreated.returnValues.taskIds;\n          for (let i = 0; i < tasks.length; i++) {\n            tasks[i].taskId = taskIds[i];\n            tasks[i].receipt = receipt;\n            tasks[i].ethStatus = 1;\n            tasks[i].creationBlockNumber = receipt.blockNumber;\n          }\n          emitter.emit(eeConstants.CREATE_TASK_RECORDS_RECEIPT, receipt);\n          emitter.emit(eeConstants.CREATE_TASK_RECORDS, tasks);\n        });\n    })();\n    return emitter;\n  }\n\n  /**\n   * Get the Task's task record status from Ethereum\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {Promise} Resolves to Task wrapper with updated ethStatus and proof properties\n   */\n  async getTaskRecordStatus(task) {\n    const result = await this.enigmaContract.methods.getTaskRecord(task.taskId).call();\n    task.ethStatus = parseInt(result.status);\n    task.proof = result.proof;\n    return task;\n  }\n\n  /**\n   * Fetch output hash for a given task\n   *\n   * @param {Task} task - Task wrapper\n   * @return {Promise} - Resolves to output hash for the task\n   */\n  async getTaskOutputHash(task) {\n    return (await this.enigmaContract.methods.getTaskRecord(task.taskId).call()).outputHash;\n  }\n\n  /**\n   * Find SGX report\n   *\n   * @param {string} custodian - Worker's address\n   * @return {Promise} Resolves to SGX report for the worker\n   */\n  async getReport(custodian) {\n    return await this.enigmaContract.methods.getReport(custodian).call();\n  }\n\n  /**\n   * Given a block number, obtain the worker parameters. These parameters remain the same for a given secret\n   * contract and epoch (fixed number of blocks). These parameters are cached until the epoch changes.\n   *\n   * @param {int} blockNumber - Block number of task record's mining\n   * @return {Promise} Resolves to the worker params, which includes a seed (random int generated from the principal\n   * node), first block number for the epoch, list of active work addresses (ordered list of worker signing addresses\n   * that were logged in at the start of the epoch), and list of active worker balances\n   */\n  async getWorkerParams(blockNumber) {\n    if ((Object.keys(this.workerParamsCache).length === 0) ||\n      (blockNumber - this.workerParamsCache.firstBlockNumber >= this.epochSize)) {\n      this.epochSize = await this.enigmaContract.methods.getEpochSize().call();\n      const getWorkerParamsResult = await this.enigmaContract.methods.getWorkerParams(blockNumber).call();\n      this.workerParamsCache = {\n        firstBlockNumber: parseInt(getWorkerParamsResult[0]),\n        seed: JSBI.BigInt(getWorkerParamsResult[1]),\n        workers: getWorkerParamsResult[2],\n        stakes: getWorkerParamsResult[3].map((x) => JSBI.BigInt(x)),\n      };\n    }\n    return this.workerParamsCache;\n  }\n\n  /**\n   * Select the workers weighted-randomly based on the staked token amount that will run the computation task\n   *\n   * @param {string} scAddr - Secret contract address\n   * @param {Object} params - Worker params (epoch first block number, seed, worker signing addresses, worker stakes)\n   * @param {number} workerGroupSize - Number of workers to be selected for task\n   * @return {Array} An array of selected workers where each selected worker is chosen with probability equal to\n   * number of staked tokens\n   */\n  selectWorkerGroup(scAddr, params, workerGroupSize = 5) {\n    // Find total number of staked tokens for workers\n    let tokenCpt = params.stakes.reduce((a, b) => JSBI.add(a, b), JSBI.BigInt(0));\n    let nonce = 0;\n    let selectedWorkers = [];\n    do {\n      // Unique hash for epoch, secret contract address, and nonce\n      const msg = abi.rawEncode(\n        ['uint256', 'bytes32', 'uint256'],\n        [params.seed.toString(10), scAddr, nonce],\n      );\n      const hash = web3Utils.keccak256(msg);\n      // Find random number between [0, tokenCpt)\n      let randVal = JSBI.remainder(JSBI.BigInt(hash), tokenCpt);\n      let selectedWorker = params.workers[params.workers.length - 1];\n      // Loop through each worker, subtracting worker's balance from the random number computed above. Once the\n      // decrementing randVal becomes negative, add the worker whose balance caused this to the list of selected\n      // workers. If worker has already been selected, increase nonce by one, resulting in a new hash computed above.\n      for (let i = 0; i < params.workers.length; i++) {\n        randVal = JSBI.subtract(randVal, params.stakes[i]);\n        if (randVal <= 0) {\n          selectedWorker = params.workers[i];\n          break;\n        }\n      }\n      if (!selectedWorkers.includes(selectedWorker)) {\n        selectedWorkers.push(selectedWorker);\n      }\n      nonce++;\n    }\n    while (selectedWorkers.length < workerGroupSize);\n    return selectedWorkers;\n  }\n\n  /**\n   * Send Task to Enigma p2p network for computation\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {EventEmitter} EventEmitter to be listened to track submission of Task to Enigma p2p network. Emits\n   * a response from the ENG network indicating whether client is ready to track the remainder of the task lifecycle\n   */\n  sendTaskInput(task) {\n    let emitter = new EventEmitter();\n    (async () => {\n      let rpcEndpointName = 'sendTaskInput';\n      let emitName = eeConstants.SEND_TASK_INPUT_RESULT;\n      if (task.isContractDeploymentTask) {\n        rpcEndpointName = 'deploySecretContract';\n        emitName = eeConstants.DEPLOY_SECRET_CONTRACT_RESULT;\n      }\n      try {\n        await new Promise((resolve, reject) => {\n          this.client.request(rpcEndpointName, Enigma.serializeTask(task), (err, response) => {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(response);\n          });\n        });\n        emitter.emit(emitName, task);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Get task result from p2p network\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {EventEmitter} EventEmitter to be listened to track getting result from Enigma network. Emits\n   * a response from the ENG network.\n   */\n  getTaskResult(task) {\n    let emitter = new EventEmitter();\n    (async () => {\n      try {\n        const getTaskResultResult = await new Promise((resolve, reject) => {\n          this.client.request('getTaskResult', {taskId: task.taskId}, (err, response) => {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(response);\n          });\n        });\n        if (getTaskResultResult.result) {\n          switch (getTaskResultResult.result.status) {\n            case 'SUCCESS':\n              task.delta = getTaskResultResult.result.delta;\n              task.ethereumPayload = getTaskResultResult.result.ethereumPayload;\n              task.ethereumAddress = getTaskResultResult.result.ethereumAddress;\n              task.preCodeHash = getTaskResultResult.result.preCodeHash;\n            case 'FAILED':\n              task.encryptedAbiEncodedOutputs = getTaskResultResult.result.output;\n              task.usedGas = getTaskResultResult.result.usedGas;\n              task.workerTaskSig = getTaskResultResult.result.signature;\n            case 'UNVERIFIED':\n            case 'INPROGRESS':\n              task.engStatus = getTaskResultResult.result.status;\n              break;\n            default:\n              throw (new Error('Invalid task result status')).message;\n          }\n        } else {\n          task.engStatus = null;\n        }\n        emitter.emit(eeConstants.GET_TASK_RESULT_RESULT, task);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Decrypt task result\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {Task} Task result wrapper with an updated decrypted output attribute\n   */\n  async decryptTaskResult(task) {\n    const {privateKey} = this.obtainTaskKeyPair();\n    const derivedKey = utils.getDerivedKey(task.workerEncryptionKey, privateKey);\n    task.decryptedOutput = utils.decryptMessage(derivedKey, task.encryptedAbiEncodedOutputs);\n    return task;\n  }\n\n  /**\n   * Generator function for polling the Enigma p2p network for task status\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @param {boolean} withResult - Task wrapper for contract deployment and compute tasks\n   */\n  * pollTaskStatusGen(task, withResult) {\n    while (true) {\n      yield new Promise((resolve, reject) => {\n        this.client.request('getTaskStatus', {\n          taskId: task.taskId, workerAddress: task.workerAddress,\n          withResult: withResult,\n        }, (err, response) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          task.engStatus = response.result.status;\n          if (withResult) {\n            task.encryptedAbiEncodedOutputs = response.result.output;\n          }\n          resolve(task);\n        });\n      });\n    }\n  }\n\n  /**\n   * Inner poll status function that continues to poll the Enigma p2p network until the task has been verified\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @param {pollTaskStatusGen} generator - Generator function for polling Enigma p2p network for task status\n   * @param {EventEmitter} emitter - EventEmitter to track Enigma p2p network polling for Task status\n   */\n  innerPollTaskStatus(task, generator, emitter) {\n    let p = generator.next();\n    p.value.then((d) => {\n      emitter.emit(eeConstants.POLL_TASK_STATUS_RESULT, d);\n      if (d.engStatus !== 'SUCCESS' && d.engStatus !== 'FAILED') {\n        this.innerPollTaskStatus(task, generator, emitter);\n      }\n    }).catch((err) => {\n      emitter.emit(eeConstants.ERROR, err);\n    });\n  }\n\n  /**\n   * Poll the Enigma p2p network for a TaskInput's status\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @param {boolean} withResult - Task wrapper for contract deployment and compute tasks\n   * @return {EventEmitter} EventEmitter to be listened to track polling the Enigma p2p network for a Task status.\n   * Emits a Task with task result attributes\n   */\n  pollTaskStatus(task, withResult = false) {\n    let emitter = new EventEmitter();\n    let generator = this.pollTaskStatusGen(task, withResult);\n    this.innerPollTaskStatus(task, generator, emitter);\n    return emitter;\n  }\n\n  /**\n   * Poll the ETH for a Task's status\n   *\n   * @param {Task} task - Task wrapper for contract deployment and compute tasks\n   * @return {Task} Task wrapper with updated ETH status.\n   */\n  async pollTaskETH(task) {\n    while (task.ethStatus === 1) {\n      task = await this.getTaskRecordStatus(task);\n      await utils.sleep(1000);\n    }\n    return task;\n  }\n\n  /**\n   * Serialize Task for submission to the Enigma p2p network depending on whether it is a deployment or compute task\n   *\n   * @param {Task} task - Task wrapper for contract deployment or compute task\n   * @return {Object} Serialized Task for submission to the Enigma p2p network\n   */\n  static serializeTask(task) {\n    return task.isContractDeploymentTask ? {\n      preCode: task.preCode,\n      encryptedArgs: utils.remove0x(task.encryptedAbiEncodedArgs), encryptedFn: utils.remove0x(task.encryptedFn),\n      userDHKey: utils.remove0x(task.userPubKey), contractAddress: utils.remove0x(task.scAddr),\n      workerAddress: task.workerAddress,\n    } : {\n      taskId: task.taskId, workerAddress: task.workerAddress,\n      encryptedFn: utils.remove0x(task.encryptedFn), encryptedArgs: utils.remove0x(task.encryptedAbiEncodedArgs),\n      contractAddress: utils.remove0x(task.scAddr), userDHKey: utils.remove0x(task.userPubKey),\n    };\n  }\n\n  /**\n   * Deterministically generate a key-secret pair necessary for deriving a shared encryption key with the selected\n   * worker. This pair will be stored in local storage for quick retrieval.\n   *\n   * @return {Object} Public key-private key pair\n   */\n  obtainTaskKeyPair() {\n    // TODO: Developer tool to allow users to select their own unique passphrase to generate private key\n    const isBrowser = typeof window !== 'undefined';\n    let privateKey;\n    let encodedPrivateKey = isBrowser ? window.localStorage.getItem('encodedPrivateKey') :\n      this.taskKeyLocalStorage['encodedPrivateKey'];\n    if (encodedPrivateKey == null) {\n      let random = forge.random.createInstance();\n      // TODO: Query user for passphrase\n      random.seedFileSync = function(needed) {\n        return forge.util.fillString('cupcake', needed);\n      };\n      privateKey = forge.util.bytesToHex(random.getBytes(32));\n      isBrowser ? window.localStorage.setItem('encodedPrivateKey', btoa(privateKey)) :\n        this.taskKeyLocalStorage['encodedPrivateKey'] = Buffer.from(privateKey, 'binary').toString('base64');\n    } else {\n      privateKey = isBrowser ? atob(encodedPrivateKey) : Buffer.from(encodedPrivateKey, 'base64').toString('binary');\n    }\n    let publicKey = EthCrypto.publicKeyByPrivateKey(privateKey);\n    return {publicKey, privateKey};\n  }\n\n  /**\n   * Create a task to deploy a secret contract - creates base task, creates task record, and sends task to the\n   * Enigma network. This is the most efficient and likely most common method for creating and deploying a secret\n   * contract.\n   *\n   * @param {string} fn - Function name\n   * @param {Array} args - Inputs for task in the form of [[arg1, '<type>'], ..., [argn, '<type>']]\n   * @param {Number} gasLimit - ENG gas limit for task computation\n   * @param {Number} gasPx - ENG gas price for task computation\n   * @param {string} sender - ETH address for task sender\n   * @param {string} preCode - Precode for contract deployment\n   * @return {Task} Task with attributes necessary for task record and Enigma network\n   */\n  deploySecretContract(fn, args, gasLimit, gasPx, sender, preCode) {\n    let emitter = new EventEmitter();\n    (async () => {\n      try {\n        let scTask = await new Promise((resolve, reject) => {\n          this.createTask(fn, args, gasLimit, gasPx, sender, preCode, true).\n            on(eeConstants.CREATE_TASK, (result) => resolve(result)).\n            on(eeConstants.ERROR, (error) => reject(error));\n        });\n        emitter.emit(eeConstants.CREATE_TASK, scTask);\n        scTask = await new Promise((resolve, reject) => {\n          this.createTaskRecord(scTask).\n            on(eeConstants.CREATE_TASK_RECORD, (result) => resolve(result)).\n            on(eeConstants.ERROR, (error) => reject(error));\n        });\n        emitter.emit(eeConstants.CREATE_TASK_RECORD, scTask);\n        await new Promise((resolve, reject) => {\n          this.sendTaskInput(scTask).\n            on(eeConstants.DEPLOY_SECRET_CONTRACT_RESULT, (receipt) => resolve(receipt)).\n            on(eeConstants.ERROR, (error) => reject(error));\n        });\n        emitter.emit(eeConstants.DEPLOY_SECRET_CONTRACT_RESULT, scTask);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Create a compute task - creates base task, creates task record, and sends task to the Enigma network. This is the\n   * most efficient and likely most common method for creating and sending a compute task.\n   *\n   * @param {string} fn - Function name\n   * @param {Array} args - Inputs for task in the form of [[arg1, '<type>'], ..., [argn, '<type>']]\n   * @param {Number} gasLimit - ENG gas limit for task computation\n   * @param {Number} gasPx - ENG gas price for task computation\n   * @param {string} sender - ETH address for task sender\n   * @param {string} scAddr - Secret contract address\n   * @return {Task} Task with attributes necessary for task record and Enigma network\n   */\n  computeTask(fn, args, gasLimit, gasPx, sender, scAddr) {\n    let emitter = new EventEmitter();\n    (async () => {\n      try {\n        let task = await new Promise((resolve, reject) => {\n          this.createTask(fn, args, gasLimit, gasPx, sender, scAddr, false).\n            on(eeConstants.CREATE_TASK, (result) => resolve(result)).\n            on(eeConstants.ERROR, (error) => reject(error));\n        });\n        emitter.emit(eeConstants.CREATE_TASK, task);\n        task = await new Promise((resolve, reject) => {\n          this.createTaskRecord(task).\n            on(eeConstants.CREATE_TASK_RECORD, (result) => resolve(result)).\n            on(eeConstants.ERROR, (error) => reject(error));\n        });\n        emitter.emit(eeConstants.CREATE_TASK_RECORD, task);\n        await new Promise((resolve, reject) => {\n          this.sendTaskInput(task).\n            on(eeConstants.SEND_TASK_INPUT_RESULT, (receipt) => resolve(receipt)).\n            on(eeConstants.ERROR, (error) => reject(error));\n        });\n        emitter.emit(eeConstants.SEND_TASK_INPUT_RESULT, task);\n      } catch (err) {\n        emitter.emit(eeConstants.ERROR, err);\n      }\n    })();\n    return emitter;\n  }\n\n  /**\n   * Return the version number of the library\n   *\n   * @return {string}\n   */\n  static version() {\n    return '0.0.1';\n  }\n}\n","import '@babel/polyfill';\n// window.Promise = Promise;\nimport utils from './enigma-utils';\nimport Enigma from './Enigma';\nimport * as eeConstants from './emitterConstants';\n\nexport {Enigma, utils, eeConstants};\n"],"sourceRoot":""}